<!DOCTYPE html>
<!-- saved from url=(0133)https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#the-implementation-of-addition-in-the-6502 -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    
    
    
    
    
    
    
    
    
    <script src="./6502_files/turbolinks.js" integrity="sha256-iM4Yzi/zLj/IshPWMC1IluRxTtRjMqjPGd97TZ9yYpU=" crossorigin="anonymous" defer=""></script>
    <link href="./6502_files/site.91f108dfe8.css" rel="stylesheet">
    <script src="./6502_files/comments-component.71b89bfe64.js" defer=""></script>
    <link href="./6502_files/css2" defer="" rel="stylesheet">
<meta name="viewport" content="width=device-width, initial-scale=1"><meta http-equiv="content-language" content="en-gb"><link rel="icon" href="https://www.middle-engine.com/favicon.ico"><title>Programming the NES: The 6502 in detail</title><meta name="description" content="The second in a series of posts about programming the Nintendo Entertainment System. I take a detailed look at programming the CPU that powers it."><meta itemprop="issueNumber" content="47"><meta http-equiv="Content-Security-Policy" content="default-src &#39;self&#39;; frame-src &#39;self&#39; https://middleengine-website-comments.vercel.app/ https://github.com/; connect-src &#39;self&#39; https://api.github.com https://cdnjs.cloudflare.com/; script-src &#39;self&#39; https://unpkg.com/ https://cdnjs.cloudflare.com/; style-src &#39;self&#39; &#39;unsafe-inline&#39; https://fonts.googleapis.com/ https://unpkg.com/ https://cdnjs.cloudflare.com/; img-src &#39;self&#39; https://*.githubusercontent.com/; font-src https://fonts.googleapis.com/ https://fonts.gstatic.com/"><link rel="apple-touch-icon" href="https://www.middle-engine.com/logo-trans192.png"><link rel="manifest" href="https://www.middle-engine.com/site.webmanifest"></head>
<body class="blog">
    <header id="site-header" data-turbolinks-permanent="">
        <div class="content-wrap">
            <h2>Middle Engine Software</h2>
            <nav aria-label="Site">
                <ul>
                    <li><a href="https://www.middle-engine.com/" class="home-link">Home</a></li>
                    <li><a href="https://www.middle-engine.com/blog" class="blog-link">Blog</a></li>
                </ul>
            </nav>
        </div>
    </header>    <main>
        <article>
            <header class="basic-hero">
                <div class="hero-text-wrap">
                    <h1>Programming the NES: The 6502 in detail</h1>
                    <div class="byline">
                        By&nbsp;
                        <address class="author"><a rel="author" href="https://www.linkedin.com/in/stephen-johns-47a7568/">Steve Johns</a>
                        </address>
                        <time pubdate="" datetime="Tue Jun 23 2020 00:00:00 GMT+0000 (Coordinated Universal Time)" title="23 June 2020">23 June 2020</time>
                    </div>
                </div>
            </header>
            <div class="article-body">
                <h2 id="introduction" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#introduction"><span>Introduction</span></a></h2>
<p>In the first post of this series, I presented an overview of the NES and its subsystems. A key component is the CPU, which is a version of the <a href="https://en.wikipedia.org/wiki/MOS_Technology_6502">MOS Technology 6502</a> CPU. To write games for the NES, it is necessary to understand how this CPU functions and how to program it using assembly. This post covers the basics that you will need.</p>
<p>The main reference used in this post is the original <a href="http://archive.6502.org/books/mcs6500_family_programming_manual.pdf">MOS MCS6500 microcomputer family programming manual</a>. It is a dense read but it does include a lot of useful advice and many worked examples. You can ignore any information about the 6502's binary coded decimal mode as it is not supported by the NES's CPU.</p>
<p>If you have not done so already, I recommend that you read the <a href="https://www.middle-engine.com/blog/posts/2020/06/22/programming-the-nes-the-nes-in-overview">first post in this series</a> before this one.</p>
<h2 id="basic-assembly-language-syntax" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#basic-assembly-language-syntax"><span>Basic assembly language syntax</span></a></h2>
<p>This section is a very basic introduction to assembly language syntax. The exact syntax will depend on your choice of compiler toolchain. The information here is correct for the toolchain that I will cover later in this series.</p>
<h3 id="literals" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#literals"><span>Literals</span></a></h3>
<h4 id="binary-literals" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#binary-literals"><span>Binary literals</span></a></h4>
<p><a href="https://en.wikipedia.org/wiki/Binary_number">Binary</a> literal values are prefixed by a percent sign, for example <code>%00000100</code>.</p>
<p>A bit is set if it has the value 1 and is clear or not set if it has the value 0. If the binary value has 8 bits then it represents one byte. Occasionally you will see two-byte values written in binary, for example <code>%0000000011111111</code>.</p>
<p>The bits of a byte are numbered from 0 to 7. Bit #0 is the least significant (rightmost) bit and bit #7 is the most significant (leftmost) bit:</p>
<p></p><figure class="article-image">  <div style="max-width: 346px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 33.381502890173415%;">      <img src="./6502_files/bit-numbers-2x.png" alt="Bit numbering" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>Bit numbering</figcaption></figure><p></p>
<h4 id="hexadecimal-literals" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#hexadecimal-literals"><span>Hexadecimal literals</span></a></h4>
<p><a href="https://en.wikipedia.org/wiki/Hexadecimal">Hexadecimal</a>, or hex, literal values are prefixed by a dollar sign, for example <code>$0F</code>.</p>
<p>Each digit in a hex literal represents a <a href="https://en.wikipedia.org/wiki/Nibble">nibble</a>. A byte consists of two nibbles, so a single byte is written as two hex digits. A two-byte value is written as four hex digits. Thus <code>$3F</code> represents a byte value and <code>$C008</code> represents a two-byte value.</p>
<p>The first byte of a two-byte value is the <a href="https://en.wikipedia.org/wiki/Bit_numbering#Most_significant_byte">most significant byte</a> (MSB). The second byte is the <a href="https://en.wikipedia.org/wiki/Bit_numbering#Least_significant_byte">least significant byte</a> (LSB). So given the hex value <code>$C008</code>, the MSB is <code>$C0</code> and the LSB is <code>$08</code>.</p>
<h4 id="decimal-literals" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#decimal-literals"><span>Decimal literals</span></a></h4>
<p>A literal value is a regular decimal value if it has no dollar sign or percent sign prefix.</p>
<h3 id="comments" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#comments"><span>Comments</span></a></h3>
<p>Comments in assembly are prefixed by a semicolon. The content of the comment is everything after the semicolon to the end of the current line.</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token comment">; This whole line is a comment</span>

<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$04</span> <span class="token comment">; This comment comes after an instruction</span>
</code></pre>
<h3 id="opcodes" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#opcodes"><span>Opcodes</span></a></h3>
<p>A program instruction represents a particular operation for the CPU to perform. It may or may not include an operand. The <a href="https://en.wikipedia.org/wiki/Opcode">instruction operation code</a> (opcode) used in the instruction identifies the operation. The opcode is a byte value in the range 0 to 255 inclusive. The 6502 supports 151 opcodes and they are grouped into <a href="http://www.6502.org/tutorials/6502opcodes.html">56 operations</a>. Each opcode in a group performs the same basic operation, such as adding two numbers together. They differ by the addressing mode used to specify the data to operate on. (I cover addressing modes later in this post.)</p>
<p>For each instruction in your program, the assembler needs to determine the opcode to use. You state the basic operation by the particular three-letter mnemonic that you use. This mnemonic is not case sensitive.</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">SEI</span>       <span class="token comment">; The mnemonic is SEI.</span>
<span class="token opcode property">sei</span>       <span class="token comment">; You can write the mnemonic in lowercase.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$0211</span> <span class="token comment">; This instruction has the mnemonic LDA</span>
          <span class="token comment">; and it is followed by an operand.</span>
</code></pre>
<p>You state the addressing mode by either omitting the operand or by the syntax you use to define it. The assembler uses the mnemonic and the addressing mode to work out which opcode to output. As an example, let us consider the operation 'Add memory to Accumulator with Carry'. It has the mnemonic <code class="language-asm6502"><span class="token opcode property">ADC</span></code>. All the following instructions use that mnemonic and an operand value of <code>$04</code>:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">ADC</span> <span class="token hexnumber string">#$04</span>     <span class="token comment">; The opcode is $69.</span>
<span class="token opcode property">ADC</span> <span class="token hexnumber string">$04</span>, <span class="token register variable">X</span>   <span class="token comment">; The opcode is $61.</span>
<span class="token opcode property">ADC</span> (<span class="token hexnumber string">$04</span>), <span class="token register variable">Y</span> <span class="token comment">; The opcode is $71.</span>
</code></pre>
<p>What differs is the syntax used to define the operand. The particular syntax you use tells the assembler which addressing mode to use. This allows it to choose which one of the <code class="language-asm6502"><span class="token opcode property">ADC</span></code> opcodes to output.</p>
<p>The assembler outputs the opcode first and the operand second, if there is one. The operand is one or two bytes in size so every machine instruction is either one, two, or three bytes in size.</p>
<p>The 6502 is little endian so any addresses in the program get encoded LSB first and MSB second. If an operation has an operand of the address <code>$1234</code> then the assembler will encode that address as <code>$3412</code>. (Here <code>$12</code> is the MSB and <code>$34</code> is the LSB.)</p>
<h3 id="labels" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#labels"><span>Labels</span></a></h3>
<p>You can use a label to associate a name with a particular location in the program code. The assembler replaces any uses of a label with the address of that location or the relative offset to it. (The exact replacement value depends on the addressing mode used.) Using labels makes your code more readable and avoids hardcoded program addresses.</p>
<p>You declare each label as a case-insensitive identifier followed by a colon. The following code declares the label <code>this_is_a_label</code>:</p>
<pre class="language-asm6502"><code class="language-asm6502">this_is_a_label:
  <span class="token opcode property">LDA</span> <span class="token hexnumber string">#$00</span>
</code></pre>
<p>You can now use this label as an operand. The following instruction jumps the program to wherever you declared the given label:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">JMP</span> this_is_a_label
</code></pre>
<p>You can also declare a label on the same line as an instruction:</p>
<pre class="language-asm6502"><code class="language-asm6502">some_label: <span class="token opcode property">LDA</span> <span class="token hexnumber string">#$00</span>
</code></pre>
<p>Some assemblers support other types of label. A <a href="https://cc65.github.io/doc/ca65.html#ss6.5">cheap local label</a> allows you to reuse common labels. For example, you can reuse the label 'loop'. This means that you do not need to create a unique label every time you loop over a series of instructions:</p>
<pre class="language-asm6502"><code class="language-asm6502">@loop:      <span class="token comment">; A cheap local label</span>
  <span class="token opcode property">JMP</span> @loop <span class="token comment">; Example usage of the cheap local label</span>
</code></pre>
<p><a href="https://cc65.github.io/doc/ca65.html#ss6.6">Unnamed labels</a> fulfil a similar role but they make the program code harder to understand:</p>
<pre class="language-asm6502"><code class="language-asm6502">:           <span class="token comment">; An unnamed label</span>
  <span class="token opcode property">JMP</span> :-    <span class="token comment">; This jumps backwards to the last unnamed label</span>
</code></pre>
<h3 id="constants" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#constants"><span>Constants</span></a></h3>
<p>Programming in assembly can involve a lot of magic values. These include the addresses of bytes in the CPU's address space that control the PPU. Assemblers usually support declaring numeric constants. These allow you to reference values by name and so improve the readability of your code:</p>
<pre class="language-asm6502"><code class="language-asm6502">PPUCTRL            = <span class="token hexnumber string">$2000</span>     <span class="token comment">; An address constant.</span>
BACKGROUND_ENABLED = <span class="token binarynumber string">%00001000</span> <span class="token comment">; A bitmask constant.</span>
</code></pre>
<p>You can use constants as instruction operands:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">STA</span> PPUCTRL
</code></pre>
<p>It is common to use uppercase for the names of constants.</p>
<h3 id="embedded-bytes" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#embedded-bytes"><span>Embedded bytes</span></a></h3>
<p>Sometimes you will need to embed data in your program. For example, you might need to embed colour palette data. An assembler will include a means for doing so. The following assembly embeds some data into the program code:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token directive keyword">.byte</span> <span class="token hexnumber string">$02</span>,<span class="token hexnumber string">$30</span>,<span class="token hexnumber string">$20</span>,<span class="token hexnumber string">$20</span> <span class="token comment">; Embeds these four one-byte values.</span>
<span class="token directive keyword">.word</span> <span class="token hexnumber string">$1234</span>           <span class="token comment">; Embeds this single two-byte value.</span>
<span class="token directive keyword">.addr</span> some_label      <span class="token comment">; Embeds the address associated with the label.</span>
</code></pre>
<p>In this assembler dialect, <code>.byte</code>, <code>.word</code> and <code>.addr</code> are instructions for the assembler. We term these assembler instructions <em>control commands</em>.</p>
<h2 id="binary-number-theory" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#binary-number-theory"><span>Binary number theory</span></a></h2>
<p>This section introduces concepts about binary numbers. This information will make later sections easier to understand.</p>
<h3 id="unsigned-and-signed-binary-values" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#unsigned-and-signed-binary-values"><span>Unsigned and signed binary values</span></a></h3>
<p>A byte consists of 8 bits, from bit #0, the least significant bit, to bit #7, the most significant bit. One interpretation of these bits is that they represent an unsigned value in the range <code>$00</code> to <code>$FF</code> (0 to 255 in decimal):</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token binarynumber string">%00000000</span> <span class="token comment">; Smallest 8-bit unsigned value (0 in decimal).</span>
<span class="token binarynumber string">%11111111</span> <span class="token comment">; Largest 8-bit unsigned value (255 in decimal).</span>
</code></pre>
<p>An alternative interpretation is that they represent a signed value. In that case, bit #7 indicates if the value is negative — when it is set — or positive — when it is not set. Bits #0 to #6 give the size of this positive or negative value. This corresponds to the <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two's complement</a> representation for signed binary values. The following values illustrate this representation:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token binarynumber string">%00000000</span> <span class="token comment">; Positive 8-bit signed value with smallest magnitude (0 in decimal).</span>
<span class="token binarynumber string">%01111111</span> <span class="token comment">; Positive 8-bit signed value with largest magnitude (+127 in decimal).</span>

<span class="token binarynumber string">%11111111</span> <span class="token comment">; Negative 8-bit signed value with smallest magnitude (-1 in decimal).</span>
<span class="token binarynumber string">%10000000</span> <span class="token comment">; Negative 8-bit signed value with largest magnitude (-128 in decimal).</span>
</code></pre>
<h3 id="multi-byte-binary-values" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#multi-byte-binary-values"><span>Multi-byte binary values</span></a></h3>
<p>We can represent larger unsigned and signed values by increasing the number of bits. For example, a 16-bit (two byte) value can represent an unsigned value in the range 0 to 65,535:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token binarynumber string">%0000000000000000</span> <span class="token comment">; Smallest 16-bit unsigned value (0 in decimal).</span>
<span class="token binarynumber string">%1111111111111111</span> <span class="token comment">; Largest 16-bit unsigned value (65,535 in decimal).</span>
</code></pre>
<p>For signed multi-byte values, regardless of the total bit count, it is always bit #7 of the MSB that is the sign bit. The following signed 16-bit values illustrate this:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token binarynumber string">%0000000000000000</span> <span class="token comment">; Positive signed value with smallest magnitude (0 in decimal).</span>
<span class="token binarynumber string">%0111111111111111</span> <span class="token comment">; Positive signed value with largest magnitude (+32,767 in decimal).</span>

<span class="token binarynumber string">%1111111111111111</span> <span class="token comment">; Negative signed value with smallest magnitude (-1 in decimal).</span>
<span class="token binarynumber string">%1000000000000000</span> <span class="token comment">; Negative signed value with largest magnitude (-32,768 in decimal).</span>
</code></pre>
<h3 id="adding-unsigned-binary-values" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#adding-unsigned-binary-values"><span>Adding unsigned binary values</span></a></h3>
<p>When we add two decimal numbers, we add the digits column by column from right to left. For each column where the total is 10 or greater, we have to carry the one to the next column to the left. We then use the remainder as the current column's result:</p>
<p></p><figure class="article-image">  <div style="max-width: 408.5px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 79.68176254589963%;">      <img src="./6502_files/addition-carry-decimal-v2-2x.png" alt="Addition example in decimal" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>Addition example in decimal</figcaption></figure><p></p>
<p>In the above example the addition in the units column is 5 plus 7 which equals 12. The result for the units column is 2 and we carry the 1 to the tens column.</p>
<p>This all still holds when adding binary numbers. The difference is that we carry the one to the left for each column where the total is 2 or greater (<code>%10</code> in binary). Here is the same addition performed using unsigned byte values:</p>
<p></p><figure class="article-image">  <div style="max-width: 531.5px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 80.15051740357478%;">      <img src="./6502_files/addition-carry-binary-v2-2x.png" alt="Addition example in binary" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>Addition example in binary</figcaption></figure><p></p>
<p>When adding binary numbers, it is not always the case that the result can fit into one byte. The following example demonstrates adding <code>$80</code> (128 in decimal) to itself:</p>
<p></p><figure class="article-image">  <div style="max-width: 520.5px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 48.99135446685879%;">      <img src="./6502_files/addition-overflow-binary-v2-2x.png" alt="Overflow when adding binary numbers" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>Overflow when adding binary numbers</figcaption></figure><p></p>
<p>There is a 9th bit, a carry bit, that is not included in the result. To capture the full result we have to use 16-bit values in the calculation. We carry that 9th bit from the LSB to bit #0 of the MSB:</p>
<p></p><figure class="article-image">  <div style="max-width: 372.5px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 39.73154362416108%;">      <img src="./6502_files/addition-overflow-16bit-binary-v2-2x.png" alt="Addition using 16-bit values" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>Addition using 16-bit values</figcaption></figure><p></p>
<p>But because the 6502 is an 8-bit CPU, we can only add byte values. The solution is to combine multiple additions. We start with the LSBs and finish with the MSBs, including any carry bits in the calculations. For example, to add <code>$80FF</code> and <code>$0003</code> (33,023 + 3 in decimal) we first add the LSBs, <code>$FF</code> and <code>$03</code>. The result is <code>$02</code> plus a carry bit. Next we add the MSBs, <code>$80</code> and <code>$00</code>, making sure to also add <code>$01</code> for that carry bit. The result is <code>$81</code> with no carry bit, so the combined result is <code>$8102</code> or 33,026 in decimal. This is a complete result because no carry bit was left after adding the MSBs.</p>
<p>Now let us try adding <code>$FFFE</code> and <code>$0003</code> (65,534 + 3 in decimal). First we add the LSBs, <code>$FE</code> and <code>$03</code>. The result is <code>$01</code> plus a carry bit. Next we add the MSBs, <code>$FF</code> and <code>$00</code>, making sure to also add <code>$01</code> for that carry bit. The result is <code>$00</code> plus a carry bit. The combined result is <code>$0001</code> (1 in decimal) but this is not the correct result (which would be 65,537 in decimal). A carry bit remains. We would have to perform this calculation using 24-bit values to get the full result.</p>
<h3 id="adding-signed-binary-values" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#adding-signed-binary-values"><span>Adding signed binary values</span></a></h3>
<p>Adding signed binary values introduces the problem of overflow. As an example, let us try adding the signed byte value <code>%01000000</code> (+64 in decimal) to itself:</p>
<p></p><figure class="article-image">  <div style="max-width: 522.5px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 48.708133971291865%;">      <img src="./6502_files/addition-signed-overflow-binary-v2-2x.png" alt="Overflow when adding signed binary values" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>Overflow when adding signed binary values</figcaption></figure><p></p>
<p>The result is <code>%10000000</code>, or 128 in decimal. This would be the correct answer if we were adding unsigned values, but we are not. This result actually represents -128 in two's complement representation. The problem is that bit #7 in a signed byte is reserved for the value's sign. Thus there is one less bit with which to represent a value's magnitude. A signed byte value can only represent values in the range -128 to +127. The correct answer of +128 lies outside that range. The result has <em>overflowed</em> the available magnitude bits.</p>
<p>When we were adding unsigned binary values, we could detect an invalid result. There was a carry bit remaining after adding the MSBs. How can we detect overflow when adding signed bytes? We have to see if the sign bit of the result is correct given the values that we have added together. In the example above we added two positive numbers, +127 and +2, so we would expect the result to be positive as well. In fact the result is negative because bit #7 of the result is set. Using this technique, we can identify the result as invalid.</p>
<p>More generally, when adding a negative value to a positive value or a positive value to a negative value, overflow cannot occur. But when the result of adding two positive values is negative or the result of adding two negative values is positive, overflow has occurred.</p>
<p>It is important to note that a remaining carry bit does <strong>not</strong> show an invalid result in the way that it does when adding unsigned values. You should in fact ignore any remaining carry bit when adding signed values.</p>
<p>We have to use 16-bit signed values in the above calculation to get the correct result. As you might expect, we have to add signed multi-byte values one byte pair at a time. We start with the LSBs and finish with the MSBs, and include any carry bits in the calculations. When performing the final addition of the MSBs, we need to check for overflow to ensure that the result is valid. We also ignore any carry bit that remains from this final addition.</p>
<p>To illustrate adding 16-bit signed values, let us add <code>$80FF</code> and <code>$FFFE</code> (-32,513 + -2 in decimal). We first add the LSBs, <code>$FF</code> and <code>$FE</code>. The result is <code>$FD</code> plus a carry bit. Next we add the MSBs, <code>$80</code> and <code>$FF</code>, making sure to also add <code>$01</code> for the carry bit. The result is <code>$80</code> with a carry bit. We can ignore the carry bit, so the combined result is <code>$80FD</code>, or -32,515 in decimal. Now we need to check if overflow occurred. We added two negative values so the result should be negative too. The result <code>$80FD</code> does indeed represent a negative value (bit #7 of the MSB is set). Overflow has not occurred and the result is valid.</p>
<h3 id="the-implementation-of-addition-in-the-6502" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#the-implementation-of-addition-in-the-6502"><span>The implementation of addition in the 6502</span></a></h3>
<p>We perform mathematical operations using the 6502's <a href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit">arithmetic logic unit</a> (ALU). The 6502 includes a Carry flag that it uses in two ways:</p>
<ol>
<li>During addition it indicates if the ALU should add one to the current addition calculation. The ALU will add one when the flag is set.</li>
<li>The ALU updates the Carry flag after an addition to indicate if the result includes a carry bit. If the Carry flag is set then the result includes a carry bit, but if the Carry flag is not set then it does not.</li>
</ol>
<p>We use the addition operation to add two byte values. The calculation that the ALU performs is the following:</p>
<pre class="language-markup"><code class="language-markup">Byte1 + Byte2 + Carry
</code></pre>
<p>Carry has the value one if the Carry flag is set, or zero if it is not.</p>
<p>When starting an addition operation, we must first ensure that the Carry flag is not set. When adding multi-byte values, we must only do this before we add the first byte pair. We must not update the state of the Carry flag as we proceed to add the other byte pairs. This way any carry bit generated by adding one byte pair gets carried over into the addition of the next byte pair.</p>
<h3 id="subtracting-binary-values" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#subtracting-binary-values"><span>Subtracting binary values</span></a></h3>
<p>In subtraction, we call the number we are subtracting from the minuend. We call the number we are subtracting by the subtrahend.</p>
<p></p><figure class="article-image">  <div style="max-width: 209.5px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 57.517899761336515%;">      <img src="./6502_files/minuend-subtrahend-2x.png" alt="Minuend and subtrahend in subtraction" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>Minuend and subtrahend in subtraction</figcaption></figure><p></p>
<p>When we subtract two decimal numbers, we subtract the digits column by column, from right to left. For each column where the result would be negative, we have to borrow one from the next column to the left:</p>
<p></p><figure class="article-image">  <div style="max-width: 410.5px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 117.90499390986602%;">      <img src="./6502_files/subtraction-borrow-decimal-v2-2x.png" alt="Borrowing when subtracting decimal values" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>Borrowing when subtracting decimal values</figcaption></figure><p></p>
<p>This all holds when subtracting binary values. The following shows subtracting 7 from 11 in binary:</p>
<p></p><figure class="article-image">  <div style="max-width: 568.5px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 80.38698328935796%;">      <img src="./6502_files/subtraction-borrow-binary-v2-2x.png" alt="Borrowing when subtracting binary values" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>Borrowing when subtracting binary values</figcaption></figure><p></p>
<p>As you can see, borrowing still applies as necessary.</p>
<h4 id="subtraction-as-addition" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#subtraction-as-addition"><span>Subtraction as addition</span></a></h4>
<p>As noted before, the ALU performs the mathematical operations. Creating an ALU that supports both addition and subtraction adds to its complexity. There is an alternative approach. We can implement subtraction as addition if we negate the subtrahend and then add it to the minuend. This is best illustrated with an example. Let us say that we want to calculate +35 - +7, which equals +28. If we negate the subtrahend then it changes value from +7 to -7. By adding it to the minuend, the calculation now becomes +35 + -7. We still get the correct answer of +28.</p>
<p>For this technique to work in the binary world of the 6502, we need to know how to negate a signed binary value. As explained earlier, the 6502 uses the two's complement representation for signed values. Thus the following negation algorithm applies:</p>
<ol>
<li>Find the one's complement of the number.</li>
<li>Add one.</li>
</ol>
<p>Finding the one's complement of a binary value means inverting its bits. All the ones become zeros and all the zeros become ones. The symbol for taking the one's complement of a number is the tilde (~).</p>
<p>Let us try calculating +35 - +7 again but this time in binary. Using the two's complement representation, this is <code>%00100011</code> - <code>%00000111</code>. The one's complement of the subtrahend is <code>%11111000</code>, or -8 in decimal. We add one to it, to give <code>%11111001</code>, or -7 in decimal. The subtraction now becomes an addition: <code>%00100011</code> + <code>%11111001</code>, or +35 + -7.</p>
<p>There is a wrinkle to how the ALU implements this. As shown earlier, the ALU implements addition like so:</p>
<pre class="language-markup"><code class="language-markup">Byte1 + Byte2 + Carry
</code></pre>
<p>The ALU implements subtraction in the same way but with a single change — it takes the one's complement of the subtrahend:</p>
<pre class="language-markup"><code class="language-markup">Byte1 + ~Byte2 + Carry
</code></pre>
<p>Thus it is the Carry flag which controls whether the 'add one' stage of the negation process is performed. Normally we want to add one, and so we have to ensure that the Carry flag is set before a subtraction operation. For example, let us calculate <code>$02</code> - <code>$01</code>, which is +2 - +1 in decimal. The ALU transforms this into the following calculation:</p>
<pre class="language-markup"><code class="language-markup">  Byte1 + ~Byte2 + Carry
= $02 + ~$01 + Carry
= $02 + $FE + Carry
= $00 + Carry
</code></pre>
<p>The correct answer to the calculation is <code>$01</code> or 1 in decimal. We only get the correct answer if the Carry flag is set:</p>
<pre class="language-markup"><code class="language-markup">  Byte1 + ~Byte2 + Carry
= $02 + ~$01 + $01
= $02 + $FE + $01
= $00 + $01
= $01
</code></pre>
<p>Thus, before performing a subtraction operation, we have to ensure that the Carry flag is set.</p>
<p>As explained before, the ALU updates the Carry flag after an addition operation to show whether the result includes a carry bit. For a subtraction operation, the ALU updates the Carry flag to indicate whether it had to borrow a bit. It is important to note that in this case, the Carry flag is set inversely by the ALU:</p>
<ul>
<li>If the Carry flag is set then the ALU did not need to borrow a bit.</li>
<li>If the Carry flag is not set then the ALU had to borrow a bit.</li>
</ul>
<p>With the previous calculation of <code>$02</code> - <code>$01</code>, the Carry flag is set after the subtraction. This is because the result of adding <code>$02</code> + <code>$FE</code> + <code>$01</code> is <code>$01</code> and a carry bit. The carry bit indicates that a bit was not borrowed, which is correct.</p>
<p>Let us try a calculation where a bit needs to be borrowed. For this, let us calculate <code>$02</code> - <code>$03</code>, which is +2 - +3 in decimal. The ALU transforms this into the following calculation:</p>
<pre class="language-markup"><code class="language-markup">  Byte1 + ~Byte2 + Carry
= $02 + ~$03 + $01
= $02 + $FC + $01
= $FE + $01
= $FF
</code></pre>
<p>The result of adding <code>$02</code> + <code>$FC</code> + <code>$01</code> is <code>$FF</code> with no carry bit, so the Carry flag is not set after this subtraction operation. If we were to actually perform this operation as a subtraction then we would need to borrow one. That is why the Carry flag not being set indicates that the ALU had to borrow a bit.</p>
<p>To get a complete result, we would have to perform this subtraction using 16-bit signed values, as <code>$0002</code> - <code>$0003</code>. As with adding multi-byte values, we have to perform the operation one byte pair at a time. We start with the LSBs and finish with the MSBs. We first ensure that the Carry flag is set before starting the subtraction process. We have already seen the subtraction of the LSBs (<code>$02</code> - <code>$03</code>):</p>
<pre class="language-markup"><code class="language-markup">  $02 + ~$03 + Carry
= $02 + ~$03 + $01
= $02 + $FC + $01
= $FE + $01
= $FF
</code></pre>
<p>The result is <code>$FF</code> with no carry bit. Now we can add the MSBs. We do not update the value of the Carry flag during the subtraction operation. The ALU performs the following calculation:</p>
<pre class="language-markup"><code class="language-markup">  $00 + ~$00 + Carry
= $00 + ~$00 + $00
= $00 + $FF + $00
= $FF + $00
= $FF
</code></pre>
<p>Thus the final answer is <code>$FFFF</code> with no carry bit. This is -1 in decimal when using the two's complement representation for binary values. As the Carry flag was not set in the MSB calculation, we did not add one. This accounted for the fact that one had to be borrowed from that byte pair.</p>
<p>Let us see how this works for some more multi-byte signed values. First let us calculate +255 - -1, which is <code>$00FF</code> - <code>$FFFF</code> in hex. We subtract the LSBs, <code>$FF</code> - <code>$FF</code>. This gets rewritten using addition as <code>$FF</code> + ~<code>$FF</code> + Carry. Carry is <code>$01</code> because that is its required initial value. This simplifies to <code>$FF</code> + <code>$00</code> + <code>$01</code>, which equals <code>$00</code> with a carry bit. Now we subtract the MSBs, <code>$00</code> - <code>$FF</code>. This gets rewritten using addition as <code>$00</code> + ~<code>$FF</code> + Carry. Here Carry is <code>$01</code> because there was a carry bit generated from adding the LSBs. This simplifies to <code>$00</code> + <code>$00</code> + <code>$01</code>, which equals <code>$01</code> with no carry bit. Thus the combined result is <code>$0100</code>, or +256 in decimal.</p>
<p>Now let us calculate +256 - +1, which is <code>$0100</code> - <code>$0001</code> in hex. We subtract the LSBs, <code>$00</code> - <code>$01</code>. This gets rewritten using addition as <code>$00</code> + ~<code>$01</code> + Carry. Carry is <code>$01</code> because that is its required initial value. This simplifies to <code>$00</code> + <code>$FE</code> + <code>$01</code>, which equals <code>$FF</code> with no carry bit. Now we subtract the MSBs, <code>$01</code> - <code>$00</code>. This gets rewritten using addition as <code>$01</code> + ~<code>$00</code> + Carry. Here Carry is <code>$00</code> as there was no carry bit generated from adding the LSBs. This simplifies to <code>$01</code> + <code>$FF</code> + <code>$00</code>, which equals <code>$00</code> with a carry bit. We know to ignore that final carry bit because we are adding signed values. The combined result is <code>$00FF</code>, or +255 in decimal.</p>
<p>In both cases, we need to ensure that overflow has not occurred when adding the MSBs. The rule for overflow when subtracting is different to the rule for overflow when adding. When subtracting two numbers, overflow occurs when their signs differ and the sign of the result is the same as the sign of the subtrahend. In the example of +255 - -1 the signs do differ, but the result (+256) is positive while the subtrahend (-1) is negative. Thus overflow has not occurred. In the case of the example of +256 - +1, the signs are the same and so overflow cannot occur.</p>
<h3 id="increasing-bit-counts" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#increasing-bit-counts"><span>Increasing bit counts</span></a></h3>
<p>When adding or subtracting two values, they should have the same bit count. If this is not the case then you need to add bits to the most significant side of the shorter value. You need to make it equal in length to the longer value. But you need to do this in a way that does not change the value being represented.</p>
<p>This is easy to do for unsigned values: you add as many significant zero bits as required. For example, you can convert the 8-bit unsigned value <code>%11111111</code> (255 in decimal) into a 16-bit value by prepending eight zero bits. This gives the value <code>%0000000011111111</code>.</p>
<p>The approach is not as obvious for signed values. The solution is <a href="https://en.wikipedia.org/wiki/Sign_extension">sign extension</a>. You still add as many significant bits as necessary, but all the added bits have the same value as the sign bit. For example, the value -128 as an 8-bit signed value is <code>%10000000</code>. The sign bit (bit #7) has the value 1 so you form the 16-bit signed value by adding an MSB with all its bits set to 1. This gives the value <code>%1111111110000000</code>, which still represents -128 in decimal.</p>
<h3 id="best-practise-for-addition-and-subtraction" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#best-practise-for-addition-and-subtraction"><span>Best practise for addition and subtraction</span></a></h3>
<p>Bear the following in mind when adding or subtracting binary values:</p>
<ol>
<li>Avoid mixing signed and unsigned values. At the very least it is difficult to know when overflow has occurred and how any carry bits should be handled.</li>
<li>The two values to add or subtract should have the same bit count. You should sign-extend the shorter value if this is not the case.</li>
<li>Ignore any carry bit that remains after adding adding or subtracting signed values. But you do need to check for overflow.</li>
</ol>
<h2 id="processor-registers" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#processor-registers"><span>Processor registers</span></a></h2>
<p>The 6502 has six <a href="https://en.wikipedia.org/wiki/Processor_register">processor registers</a>. These are special data storage areas that are separate from the CPU's address space. These registers allow the 6502 to execute instructions faster than it could if it only had access to system RAM. Each has a special role within the CPU.</p>
<p>The six registers, along with their abbreviations, are:</p>
<ul>
<li>The Program Counter (PC).</li>
<li>The Stack Pointer (S).</li>
<li>The Processor Status (P).</li>
<li>The Accumulator (A).</li>
<li>Index Register X (X).</li>
<li>Index Register Y (Y).</li>
</ul>
<p>The <strong>Program Counter</strong> (PC) stores the address of the next instruction to be executed. The CPU automatically updates that address as it sequentially executes your program. You can also use instructions to update the value of the Program Counter to a particular address.</p>
<p>This register is two bytes in size because the Program Counter stores an address. (The 6502 uses 16-bit addresses.) The rest of the registers each hold a single data value and, since the 6502 has an 8-bit data bus, all are one byte in size.</p>
<p>The <strong>Accumulator</strong> (A) is the main register that instructions operate on. Many instructions use it in their inputs or write their result to it. It is also useful as a temporary storage area when moving data from one memory location to another.</p>
<p><strong>Index Register X</strong> (X) and <strong>Index Register Y</strong> (Y) are more simply called the X register and the Y register. Each can be used to specify a particular byte in the address space for an instruction to operate on. The address of that byte is the sum of some base address and the current value in the register. For example, an instruction might using the X register with a base address of <code>$0C01</code>. If the current value in the X register is <code>$02</code> then the address accessed by the instruction will be <code>$0C03</code> (<code>$0C01</code> plus <code>$02</code>). Indexing in this way is useful when you want to iterate through a sequence of bytes in memory. You can also use these index registers as temporary storage areas.</p>
<p>The <strong>Stack Pointer</strong> (S) is used to point to the next free byte in the 6502's call stack. I cover the call stack in detail later in this post.</p>
<p>Finally there is the <strong>Processor Status</strong> (P) register. This register actually operates as eight flag bits. Each bit indicates if some particular processor status is currently true or not. A bit is set if it is a one, and clear or not set if it is a zero. Only seven out of the eight flag bits are used; bit #5 is unused.</p>
<p></p><figure class="article-image">  <div style="max-width: 634.5px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 56.65878644602049%;">      <img src="./6502_files/processor-status-register-2x.png" alt="The Processor Status register flags" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>The Processor Status register flags</figcaption></figure><p></p>
<p>The <strong><a href="https://en.wikipedia.org/wiki/Carry_flag">Carry</a></strong> (C) flag is used by the ALU as a carry or borrow bit for addition and subtraction. The ALU also uses it as a ninth bit for the bit shifting operations.</p>
<p>Before an addition, you need to set the Carry flag if it should include a carry bit or clear it if it should not. The ALU then updates this flag when the addition operation is complete. It gets set if the result of the addition includes a carry bit, and it gets cleared if the result does not.</p>
<p>Before a subtraction, you need to set the Carry flag if it should not include a borrow bit or clear it if it should. The ALU then updates this flag when the subtraction operation is complete. It gets set if it did not need to borrow a bit, and it gets cleared if it did.</p>
<p>(The borrowing is conceptual since the ALU turns subtraction into addition.)</p>
<p>The <strong>Negative</strong> (N) flag is useful when values are being interpreted as signed values. The most significant bit (the sign bit) indicates if the value is positive or negative. Some instructions update this flag to the same state as bit #7 of the instruction result. If we know that the instruction result is the MSB of a signed value, this flag indicates if the value is positive or negative.</p>
<p>The ALU sets the <a href="https://en.wikipedia.org/wiki/Overflow_flag"><strong>Overflow</strong></a> (V) flag when the sign bit of the result of an addition or subtraction does not have the expected state. This is specifically when the values being added or subtracted are interpreted as signed 8-bit values. It is only useful to check for overflow after adding or subtracting the MSBs of two signed values. If the Overflow flag is set then overflow has occurred and the result is not valid. If this flag is not set then overflow has not occurred.</p>
<p>The Overflow and Negative flags are useful if you want to check the state of bit #6 or bit #7 of some byte. For example, you can use a BIT instruction to do this for any byte in memory (as discussed later in this post). These flags makes these bit positions cheap to test. Any flag bytes in your program should generally use bit #6 or bit #7 for the flags that you will check most.</p>
<p>The <strong>Zero</strong> (Z) flag is set by some instructions if the result of the instruction is zero (i.e., <code>$00</code>). For example, subtracting <code>$04</code> from <code>$04</code> equals <code>$00</code>, which would result in the Zero flag being set.</p>
<p>The <strong>Interrupt Disable</strong> (I) flag indicates if maskable interrupts are disabled or enabled. They are disabled when the flag is set and enabled when the flag is not set. I cover interrupts later in this post.</p>
<p>The CPU updates the <strong>Break</strong> (B) flag as appropriate. It is useful in an interrupt handler if you need to determine how an interrupt was triggered. It could have been because of a BRK instruction or a normal maskable interrupt.</p>
<p>The <strong>Decimal Mode</strong> (D) flag is used to control if the CPU is in binary coded decimal mode or not. The flag can be set and cleared, but this has no effect on the CPU's operation. The CPU used in the NES does not implement this mode.</p>
<h2 id="addressing-modes" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#addressing-modes"><span>Addressing modes</span></a></h2>
<p>A program instruction represents a particular operation on a particular byte of data. The instruction's three-letter mnemonic determines the particular operation. The byte of data to operate on can be specified in several ways. Each means of specifying that byte of data is termed an addressing mode. The 6502 has thirteen such modes:</p>
<ul>
<li>Implied</li>
<li>Accumulator</li>
<li>Immediate</li>
<li>Absolute</li>
<li>Zero Page</li>
<li>Absolute, X</li>
<li>Absolute, Y</li>
<li>Zero Page, X</li>
<li>Zero Page, Y</li>
<li>(Indirect, X)</li>
<li>(Indirect), Y</li>
<li>Absolute Indirect</li>
<li>Relative</li>
</ul>
<p>Each of the 6502's operations support one or more of these addressing modes.</p>
<p>In the <strong>Implied</strong> addressing mode, it is the operation itself that implies the byte to operate on. For example, the CLC (Clear Carry Flag) operation clears the Carry flag of the Processor Status register. The byte to operate on — the Processor Status register — is implied; you cannot specify a different byte of data.</p>
<p>Related to the implied addressing mode is the <strong>Accumulator</strong> addressing mode. This takes the form <code>&lt;mnemonic&gt; A</code>. It specifies that the byte to operate on is the value in the Accumulator (hence 'A').</p>
<p>Instructions that use the Implied or Accumulator addressing modes are always one byte long because they have no operand. The rest of the addressing modes need an operand to specify the byte of data to operate on. I will mainly use the LDA (Load Accumulator with memory) operation to illustrate these addressing modes. It is used to load a byte of data from memory into the Accumulator.</p>
<p>The <strong>Immediate</strong> addressing mode takes the form <code>&lt;mnemonic&gt; #&lt;some_byte_value&gt;</code>. The <code>&lt;some_byte_value&gt;</code> is the byte to operate on. It is embedded in the instruction. An instruction that uses this addressing mode will be two bytes long: one byte for the opcode and one byte for the embedded byte value. The following example loads the value <code>$04</code> into the Accumulator:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">LDA</span> <span class="token hexnumber string">#$04</span>
</code></pre>
<p>The <strong>Absolute</strong> addressing mode takes the form <code>&lt;mnemonic&gt; &lt;some_address&gt;</code>. The <code>&lt;some_address&gt;</code> is a two-byte address in the CPU's address space. It is the byte at this address that will be operated on. An instruction that uses this addressing mode will be three bytes long: one byte for the opcode and two bytes for the address. The following example loads the byte at address <code>$027E</code> into the Accumulator:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">LDA</span> <span class="token hexnumber string">$027E</span>
</code></pre>
<p>A variation on the absolute addressing mode is the <strong>Zero Page</strong> addressing mode. This takes the form <code>&lt;mnemonic&gt; $&lt;some_byte_value&gt;</code>. The <code>&lt;some_byte_value&gt;</code> specifies an address within the zero page. The zero page is the first 256 bytes of the CPU's address space, from addresses <code>$0000</code> to <code>$00FF</code>. The most significant byte of a zero page address will always be <code>$00</code>. Thus we only need a single byte to specify an address within it. It is the byte at this address that will be operated on. An instruction that uses this addressing mode will be two bytes long: one byte for the opcode and one byte for the address LSB. The following example loads the byte at address <code>$007E</code> into the Accumulator:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">LDA</span> <span class="token hexnumber string">$7E</span>
</code></pre>
<p>You could have used the Absolute addressing mode to load this byte, using the instruction <code>LDA $007E</code>. But there are advantages to the Zero Page addressing mode:</p>
<ul>
<li>The instruction is smaller, being two bytes rather than three.</li>
<li>The instruction will take one less cycle to execute.</li>
</ul>
<p>The 6502 has relatively few registers. The Zero Page addressing mode compensates somewhat for this by making the zero page more efficient to access than the rest of system RAM. Because of this, you should store your most accessed values in the zero page.</p>
<p>There are four addressing modes that are indexed variations of the Absolute and Zero Page addressing modes. They are <strong>Absolute, X</strong>, <strong>Absolute, Y</strong>, <strong>Zero Page, X</strong>, and <strong>Zero Page, Y</strong>. For each, the address of the byte to operate on is found by adding the current value in the X or Y register to the address specified in the instruction. Thus the address in the instruction is the base address to which the CPU adds an index value. This gives the final address of the byte to operate on. (This usage is the reason why we call the X and Y registers the index registers.) We show this mode by appending <code>, X</code> or <code>, Y</code> as appropriate.</p>
<p>The following example instructions demonstrate these four modes:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">LDA</span> <span class="token hexnumber string">$027E</span>, <span class="token register variable">X</span>  <span class="token comment">; Absolute, X</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$7E</span>, <span class="token register variable">X</span>    <span class="token comment">; Zero Page, X</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$027E</span>, <span class="token register variable">Y</span>  <span class="token comment">; Absolute, Y</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$7E</span>, <span class="token register variable">Y</span>    <span class="token comment">; Zero Page, Y</span>
</code></pre>
<p>These indexed addressing modes are useful when you want to loop through some part of the address space. They allow you to write fewer instructions compared to an <a href="https://en.wikipedia.org/wiki/Loop_unrolling">unrolled loop</a>, at the expense of increased execution time. But be aware: in the zero page form the result is always an address within the zero page. For example, if the instruction <code>LDA $FF, X</code> is executed when the X register contains the value <code>$02</code>, then the address accessed is not <code>$0101</code> (<code>$FF</code> + <code>$02</code>). It is instead <code>$0001</code>. Only the LSB of the address changes when indexing within the zero page.</p>
<p>Up to now, the addressing modes that specify an address have done so by hard-coding it. But what if it is only at runtime that you will know the address to use? What if you want to have a pointer to the code to execute when some user action occurs? What if you want to sometimes change that pointer at runtime to point to different code? These are the scenarios that the various indirect addressing modes support.</p>
<p>There are two indexed indirect addressing modes. The first one is the <strong>(Indirect, X)</strong> addressing mode and it takes the form <code>&lt;mnemonic&gt; (&lt;some_byte_value&gt;, X)</code>. The <code>&lt;some_byte_value&gt;</code> specifies an address within the zero page. The value in the X register is added to this address. The result again specifies an address within the zero page. The byte of data at this adjusted address is then read, along with the byte after it. The two bytes are interpreted respectively as the LSB and MSB of an address somewhere in the CPU's address space. It is this final address that identifies the byte of data the instruction should operate on.</p>
<p>The following is an example instruction that uses this addressing mode:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">LDA</span> (<span class="token hexnumber string">$04</span>, <span class="token register variable">X</span>)
</code></pre>
<p>The address specified represents the address <code>$0004</code>. The CPU first adds the current value in the X register to it. If the value in the X register is <code>$02</code> then the resulting address will be <code>$0006</code>. The CPU now reads the value of the byte at address <code>$0006</code> and the value of the byte after it. It combines them to create a two-byte address. If the value of the byte at address <code>$0006</code> is <code>$34</code> and the value of the byte at address <code>$0007</code> is <code>$12</code> then the result will be <code>$1234</code>. This is the address that identifies the byte of data that the instruction should operate on. In this example, it is the byte in memory at address <code>$1234</code> that the CPU will load into the Accumulator.</p>
<p>Note that adding the value in the X register to the zero page address always gives another zero page address. Only the LSB of the address gets adjusted. This is the same as with the Zero Page, X and Zero Page, Y addressing modes. For example, if the instruction is <code>LDA ($FF, X)</code> and the value in the X register is <code>$00</code>, then the CPU reads the value of the bytes at addresses <code>$00FF</code> and <code>$0000</code>. It does not read the bytes at addresses <code>$00FF</code> and <code>$0100</code>.</p>
<p>The second indexed indirect addressing mode is the <strong>(Indirect), Y</strong> addressing mode. It takes the form <code>&lt;mnemonic&gt; (&lt;some_byte_value&gt;), Y</code>. The <code>&lt;some_byte_value&gt;</code> again specifies an address within the zero page, but indexing behaves differently. The CPU reads the byte of data at this zero page address along with the byte after it. It interprets the two bytes respectively as the LSB and MSB of a base address somewhere in the CPU's address space. The value in the Y register is then added to this base address. This creates the final address of the byte of data that the instruction should operate on.</p>
<p>The following is an example instruction that uses this addressing mode:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">LDA</span> (<span class="token hexnumber string">$04</span>), <span class="token register variable">Y</span>
</code></pre>
<p>The address specified represents the address <code>$0004</code>. The CPU reads the value of the byte at address <code>$0004</code> and then reads the value of the byte after it. It combines them to create a two-byte address. If the value of the byte at address <code>$0004</code> is <code>$34</code> and the value of the byte at address <code>$0005</code> is <code>$12</code>, the resulting address is <code>$1234</code>. The CPU now adds the value in the Y register to this address. If the value in the Y register is <code>$02</code> then the result will be <code>$1236</code>. This is the address that identifies the byte of data that the instruction should operate on. In this example, the CPU will load the byte in memory at address <code>$1236</code> into the Accumulator.</p>
<p>If the zero page address specified in the instruction is <code>$FF</code>, the CPU reads the bytes at addresses <code>$00FF</code> and <code>$0000</code>. It does not read the bytes at addresses <code>$00FF</code> and <code>$0100</code>.</p>
<p>There is a third indirect addressing mode, the <strong>Absolute Indirect</strong> addressing mode. It is only used with the JMP operation. It takes the form <code>JMP (&lt;some_address&gt;)</code> (note the parentheses). The <code>&lt;some_address&gt;</code> is an address in the CPU's address space. At runtime, the CPU reads the byte of data at this address along with the byte after it. The CPU interprets these two bytes respectively as the LSB and MSB of an address that it uses to update the Program Counter.</p>
<p>The following is an example JMP instruction that uses this addressing mode:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">JMP</span> (<span class="token hexnumber string">$1234</span>)
</code></pre>
<p>The CPU reads the value of the byte at address <code>$1234</code> and the value of the byte after it. It combines them to create a two-byte address. If the value of the byte at address <code>$1234</code> is <code>$78</code> and the value of the byte at address <code>$1235</code> is <code>$56</code>, the resulting address is <code>$5678</code>. This is the address that the CPU updates the Program Counter to. Program execution now jumps to that address.</p>
<p>The final addressing mode is the <strong>Relative</strong> addressing mode. This is an addressing mode used exclusively by the branch operations. (I cover those operations later in this post.) This mode takes the form <code>&lt;mnemonic&gt; &lt;some_signed_byte_value&gt;</code>. The <code>some_signed_byte_value</code> is a single byte that the CPU interprets as a two's complement signed value. The magnitude of this value indicates by how much the CPU should adjust the Program Counter by. Its sign indicates if the adjustment should be forwards (a positive value) or backwards (a negative value). Program execution then continues from the adjusted address.</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">BMI</span> <span class="token hexnumber string">$7F</span> <span class="token comment">; Jump forward 127 bytes if the branch condition is true.</span>

<span class="token opcode property">BMI</span> <span class="token hexnumber string">$80</span> <span class="token comment">; Jump backward 128 bytes if the branch condition is true.</span>
</code></pre>
<p>Normally you would use a label as the operand:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">BMI</span> some_label <span class="token comment">; Jump forward or backward to some_label</span>
               <span class="token comment">; if the branch condition is true.</span>
</code></pre>
<p>Since a single signed byte value is used to indicate the adjustment, it can only be in the range -128 to +127. You cannot adjust the Program Counter beyond this range. This includes when using a label. I discuss this restriction when I cover branching.</p>
<h2 id="the-operations-in-detail" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#the-operations-in-detail"><span>The operations in detail</span></a></h2>
<p>The 6502 supports 151 opcodes, grouped into <a href="http://www.6502.org/tutorials/6502opcodes.html">56 operations</a>. I summarise each operation in this section. This includes its addressing modes and how it updates the Process Status register.</p>
<h3 id="running-the-assembly-code-examples" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#running-the-assembly-code-examples"><span>Running the assembly code examples</span></a></h3>
<p>I include examples of 6502 assembly to show various algorithms and patterns. You can run most of them as-is in a 6502 emulator. The easiest one to use <a href="http://biged.github.io/6502js/">this browser-based 6502 emulator</a>. Note that it has limitations, such as not supporting binary literals and constants.</p>
<p>To use the emulator:</p>
<ol>
<li>Copy and paste or manually enter the assembly code into the large text area.</li>
<li>Click the Assemble button. You can check for any assembler errors in the message box at the bottom of the page.</li>
<li>Click the Run button to run the program.</li>
</ol>
<p>It shows the state of the registers after the program runs in the righthand column. To see the state of the system RAM, tick the Monitor option below the text area.</p>
<h3 id="operations-for-setting-and-clearing-the-processor-status-register-flags" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#operations-for-setting-and-clearing-the-processor-status-register-flags"><span>Operations for setting and clearing the Processor Status register flags</span></a></h3>
<p>Some of the Processor Status register flags can be set and/or cleared by the programmer. This is generally only useful in specific situations. Examples include before addition and subtraction, and when handling an interrupt. I have included the operations for setting and clearing the Decimal Mode flag. Remember that the CPU in the NES does not support that mode.</p>
<section class="opcode-detail">
<h5>SEC (Set Carry Flag)</h5>
<p>Sets the Carry flag of the Processor Status register.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">SEC</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>CLC (Clear Carry Flag)</h5>
<p>Clears the Carry flag of the Processor Status register.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">CLC</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>CLV (Clear Overflow Flag)</h5>
<p>Clears the Overflow flag of the Processor Status register.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">CLV</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>SEI (Set Interrupt Disable Flag)</h5>
<p>Sets the Interrupt Disable flag of the Processor Status register.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">SEI</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>CLI (Clear Interrupt Disable Flag)</h5>
<p>Clears the Interrupt Disable flag of the Processor Status register.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">CLI</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>SED (Set Decimal Mode)</h5>
<p>Sets the Decimal Mode flag of the Processor Status register.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">SED</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>CLD (Clear Decimal Mode)</h5>
<p>Clears the Decimal Mode flag of the Processor Status register.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">CLD</span></code></td>
</tr>
</tbody>
</table>
</section>
<h3 id="operations-for-transferring-bytes-of-data" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#operations-for-transferring-bytes-of-data"><span>Operations for transferring bytes of data</span></a></h3>
<p>Many of the instructions in your programs will be for shuffling data around. This is because very few operations mutate data in place in memory. You need to instead load a value into a register, operate on it, and then store the result somewhere.</p>
<p>The following diagram shows the supported transfers:</p>
<p></p><figure class="article-image">  <div style="max-width: 669px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 58.819133034379675%;">      <img src="./6502_files/transfer-opcodes-2x.png" alt="The transfers supported by the data transfer operations" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>The transfers supported by the data transfer operations</figcaption></figure><p></p>
<p>As this diagram shows, it is not possible to transfer directly between the X and Y registers.</p>
<section class="opcode-detail">
<h5>LDA (Load Accumulator with memory)</h5>
<p>Loads the specified byte into the Accumulator.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the specified byte is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the specified byte.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Immediate</td>
<td><code class="language-asm6502"><span class="token opcode property">LDA</span> <span class="token hexnumber string">#$00</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">LDA</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">LDA</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">LDA</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Absolute, Y</td>
<td><code class="language-asm6502"><span class="token opcode property">LDA</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">Y</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">LDA</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>(Indirect, X)</td>
<td><code class="language-asm6502"><span class="token opcode property">LDA</span> (<span class="token hexnumber string">$00</span>, <span class="token register variable">X</span>)</code></td>
</tr>
<tr>
<td>(Indirect), Y</td>
<td><code class="language-asm6502"><span class="token opcode property">LDA</span> (<span class="token hexnumber string">$00</span>), <span class="token register variable">Y</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>LDX (Load Index Register X with memory)</h5>
<p>Loads the specified byte into the X register.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the specified byte is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the specified byte.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Immediate</td>
<td><code class="language-asm6502"><span class="token opcode property">LDX</span> <span class="token hexnumber string">#$00</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">LDX</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">LDX</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, Y</td>
<td><code class="language-asm6502"><span class="token opcode property">LDX</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">Y</span></code></td>
</tr>
<tr>
<td>Zero Page, Y</td>
<td><code class="language-asm6502"><span class="token opcode property">LDX</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">Y</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>LDY (Load Index Register Y with memory)</h5>
<p>Loads the specified byte into the Y register.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the specified byte is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the specified byte.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Immediate</td>
<td><code class="language-asm6502"><span class="token opcode property">LDY</span> <span class="token hexnumber string">#$00</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">LDY</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">LDY</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">LDY</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">LDY</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>STA (Store Accumulator in memory)</h5>
<p>Copies the value in the Accumulator to the specified memory location.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">STA</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">STA</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Absolute, Y</td>
<td><code class="language-asm6502"><span class="token opcode property">STA</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">Y</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>(Indirect, X)</td>
<td><code class="language-asm6502"><span class="token opcode property">STA</span> (<span class="token hexnumber string">$00</span>, <span class="token register variable">X</span>)</code></td>
</tr>
<tr>
<td>(Indirect), Y</td>
<td><code class="language-asm6502"><span class="token opcode property">STA</span> (<span class="token hexnumber string">$00</span>), <span class="token register variable">Y</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>STX (Store Index Register X in memory)</h5>
<p>Copies the value in the X register to the specified memory location.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">STX</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">STX</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, Y</td>
<td><code class="language-asm6502"><span class="token opcode property">STX</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">Y</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>STY (Store Index Register Y in memory)</h5>
<p>Copies the value in the Y register to the specified memory location.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">STY</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">STY</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">STY</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>TAX (Transfer Accumulator to Index Register X)</h5>
<p>Copies the value in the Accumulator to the X register.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the copied byte is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the copied byte.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">TAX</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>TAY (Transfer Accumulator to Index Register Y)</h5>
<p>Copies the value in the Accumulator to the Y register.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the copied byte is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the copied byte.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">TAY</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>TXA (Transfer Index Register X to Accumulator)</h5>
<p>Copies the value in the X register to the Accumulator.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the copied byte is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the copied byte.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">TXA</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>TYA (Transfer Index Register Y to Accumulator)</h5>
<p>Copies the value in the Y register to the Accumulator.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the copied byte is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the copied byte.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">TYA</span></code></td>
</tr>
</tbody>
</table>
</section>
<p>The two operations below are for data transfers between the X register and the Stack Pointer. I cover their usage later in this post in the section on the call stack.</p>
<section class="opcode-detail">
<h5>TXS (Transfer Index Register X to Stack Pointer)</h5>
<p>Copies the value in the X register to the Stack Pointer.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">TXS</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>TSX (Transfer Stack Pointer to Index Register X)</h5>
<p>Copies the value in the Stack Pointer to the X register.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the copied byte is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the copied byte.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">TSX</span></code></td>
</tr>
</tbody>
</table>
</section>
<p>The following assembly demonstrates how you can use these data transfer operations. I store a given 16-bit value in memory and then copy it to another memory location:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token comment">; Store the 16-bit value $0123 into system RAM, in little endian format.</span>

<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$23</span>  <span class="token comment">; Load LSB as an immediate value into the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>   <span class="token comment">; Store the Accumulator in memory at address $0000.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$01</span>  <span class="token comment">; Load MSB as an immediate value into the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$01</span>   <span class="token comment">; Store the Accumulator in memory at address $0001.</span>

<span class="token comment">; Copy that value to another location in system RAM.</span>

<span class="token opcode property">LDA</span> <span class="token hexnumber string">$00</span>   <span class="token comment">; Load LSB from address $0000 into the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$02</span>   <span class="token comment">; Store the Accumulator in memory at address $0002.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$01</span>   <span class="token comment">; Load MSB from address $0001 into the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$03</span>   <span class="token comment">; Store the Accumulator in memory at address $0003.</span>
</code></pre>
<p>After this code runs, the sequence of bytes at the start of the zero page is now <code>$23 $01 $23 $01</code>.</p>
<h3 id="addition" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#addition"><span>Addition</span></a></h3>
<p>Addition is performed using the ADC operation.</p>
<section class="opcode-detail">
<h5>ADC (Add memory to Accumulator with Carry)</h5>
<p>Adds three values together: the current value in the Accumulator, the byte value specified by the operand, and the Carry flag. The result of the addition is stored in the Accumulator.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Carry flag</td>
<td>Set if the result includes a carry bit, otherwise cleared.</td>
</tr>
<tr>
<td>Overflow flag</td>
<td>Set if bit #7 of the result changed in a way that indicates overflow when adding signed byte values, otherwise cleared.</td>
</tr>
<tr>
<td>Zero flag</td>
<td>Set if the result is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the result.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Immediate</td>
<td><code class="language-asm6502"><span class="token opcode property">ADC</span> <span class="token hexnumber string">#$00</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">ADC</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">ADC</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">ADC</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Absolute, Y</td>
<td><code class="language-asm6502"><span class="token opcode property">ADC</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">Y</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">ADC</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>(Indirect, X)</td>
<td><code class="language-asm6502"><span class="token opcode property">ADC</span> (<span class="token hexnumber string">$00</span>, <span class="token register variable">X</span>)</code></td>
</tr>
<tr>
<td>(Indirect), Y</td>
<td><code class="language-asm6502"><span class="token opcode property">ADC</span> (<span class="token hexnumber string">$00</span>), <span class="token register variable">Y</span></code></td>
</tr>
</tbody>
</table>
</section>
<p>The following assembly demonstrates adding together two 8-bit unsigned values:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token comment">; $FE + $01 (254 + 1 in decimal)</span>

<span class="token opcode property">CLC</span>       <span class="token comment">; Clear the Carry flag.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$FE</span>  <span class="token comment">; Load $FE as an immediate value into Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>   <span class="token comment">; Store Accumulator in memory at address $0000.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$01</span>  <span class="token comment">; Load $01 as an immediate value into Accumulator.</span>
<span class="token opcode property">ADC</span> <span class="token hexnumber string">$00</span>   <span class="token comment">; Add value at address $0000 to the Accumulator.</span>
</code></pre>
<p>After this code runs, the value in the Accumulator is now <code>$FF</code> and the Carry flag is not set. Thus there is no carry bit and the result still fits into one byte.</p>
<p>The CLC instruction in the example above is important. Before starting an addition operation, you need to ensure that the Carry flag is not set. If it is, the result will be incorrect. (It is possible for the Carry flag to be set if, say, a previous addition or subtraction operation set it.)</p>
<p>The following assembly demonstrates adding two 8-bit unsigned values. In this case the result will not fit into a single byte:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token comment">; $FE + $03 (254 + 3 in decimal)</span>

<span class="token opcode property">CLC</span>       <span class="token comment">; Clear the Carry flag.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$FE</span>  <span class="token comment">; Load $FE as an immediate value into the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>   <span class="token comment">; Store Accumulator in memory at address $0000.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$03</span>  <span class="token comment">; Load $01 as an immediate value into the Accumulator.</span>
<span class="token opcode property">ADC</span> <span class="token hexnumber string">$00</span>   <span class="token comment">; Add value at address $0000 to the Accumulator.</span>
</code></pre>
<p>After this code runs, the value in the Accumulator is <code>$01</code> and the Carry flag is set. We are missing the 9th carry bit in the result. Instead we have to perform the calculation using 16-bit unsigned values:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token comment">; $00FE + $0003 (254 + 3 in decimal)</span>

<span class="token comment">; Store LSB of first value in memory at address $0000.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$FE</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>

<span class="token comment">; Store MSB of first value in memory at address $0001.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$00</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$01</span>

<span class="token comment">; Store LSB of second value in memory at address $0002.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$03</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$02</span>

<span class="token comment">; Store MSB of second value in memory at address $0003.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$00</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$03</span>

<span class="token opcode property">CLC</span>       <span class="token comment">; Clear the Carry flag.</span>

<span class="token comment">; Add the LSBs</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$00</span>   <span class="token comment">; Load LSB of first value into the Accumulator.</span>
<span class="token opcode property">ADC</span> <span class="token hexnumber string">$02</span>   <span class="token comment">; Add LSB of second value to the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$04</span>   <span class="token comment">; Store LSB of result in memory at address $0004.</span>

<span class="token comment">; Add the MSBs, including the carry bit from the first addition.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$01</span>   <span class="token comment">; Load MSB of first value into the Accumulator.</span>
<span class="token opcode property">ADC</span> <span class="token hexnumber string">$03</span>   <span class="token comment">; Add MSB of second value to the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$05</span>   <span class="token comment">; Store LSB of result in memory at address $0005.</span>
</code></pre>
<p>The following assembly demonstrates adding two 8-bit signed values:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token comment">; $7E + $FB (+120 + -5 in decimal)</span>

<span class="token opcode property">CLC</span>       <span class="token comment">; Clear the Carry flag.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$7E</span>  <span class="token comment">; Load $7E as an immediate value into the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>   <span class="token comment">; Store the Accumulator in memory at address $0000.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$FB</span>  <span class="token comment">; Load $FB as an immediate value into the Accumulator.</span>
<span class="token opcode property">ADC</span> <span class="token hexnumber string">$00</span>   <span class="token comment">; Add value at address $0000 to the Accumulator.</span>
</code></pre>
<p>After this code runs, the Carry flag is set and the Overflow flag is not set. We are adding signed values so we are only interested in checking for overflow. Since the Overflow flag is not set, the result is valid. But if we change the above addition to <code>$80</code> + <code>$FB</code>, or -128 + -5 in decimal, the Overflow flag would get set. Thus the result would be invalid. The answer is to use 16-bit signed values:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token comment">; $FF80 + $FFFB (-128 + -5 in decimal)</span>

<span class="token comment">; Store LSB of -128 in memory at address $0000.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$80</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>

<span class="token comment">; Store MSB of -128 in memory at address $0001.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$FF</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$01</span>

<span class="token comment">; Store LSB of -5 in memory at address $0002.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$FB</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$02</span>

<span class="token comment">; Store MSB of -5 in memory at address $0003.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$FF</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$03</span>

<span class="token opcode property">CLC</span>       <span class="token comment">; First clear the Carry flag.</span>

<span class="token comment">; Add the LSBs</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$00</span>   <span class="token comment">; Load LSB of first value into the Accumulator.</span>
<span class="token opcode property">ADC</span> <span class="token hexnumber string">$02</span>   <span class="token comment">; Add LSB of second value to the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$04</span>   <span class="token comment">; Store LSB of result in memory at address $0004.</span>

<span class="token comment">; Add the MSBs, including any carry bit from the first addition.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$01</span>   <span class="token comment">; Load MSB of first value into the Accumulator.</span>
<span class="token opcode property">ADC</span> <span class="token hexnumber string">$03</span>   <span class="token comment">; Add MSB of second value to the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$05</span>   <span class="token comment">; Store LSB of result in memory at address $0005.</span>
</code></pre>
<p>Earlier I described how to use sign extension to add two signed values with different bit counts. Now I can show you how to add an 8-bit signed value — a delta value — to a 16-bit signed value, as discussed <a href="https://codebase64.org/doku.php?id=base:signed_8bit_16bit_addition">here</a>. In the following assembly, I first sign-extend the delta value before the addition:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token comment">; $0030 + $9C = $FFCC</span>
<span class="token comment">; In decimal: +48 + -100 = -52</span>

<span class="token comment">; Store LSB of $0030 in memory at address $0000.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$30</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>

<span class="token comment">; Store MSB of $0030 in memory at address $0001.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$00</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$01</span>

<span class="token comment">; Store the delta value $9C in memory at address $0002.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$9C</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$02</span>

<span class="token comment">; Precalculate the sign-extended high byte of the delta value</span>
<span class="token comment">; and store it in the X register.</span>
<span class="token comment">; If delta is positive then we store an all zeros byte in the X register.</span>
<span class="token comment">; If delta is negative then we store an all ones byte in the X register.</span>

<span class="token opcode property">LDX</span> <span class="token hexnumber string">#$00</span> <span class="token comment">; Load $00 into the X register.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$02</span>  <span class="token comment">; Load the delta value into the Accumulator.</span>
<span class="token opcode property">BPL</span> sign_extended <span class="token comment">; Skip the decrement if the delta value is positive.</span>
  <span class="token opcode property">DEX</span> <span class="token comment">; Decrementing zero by one results in a byte of all ones,</span>
      <span class="token comment">; which is the correct high byte for a negative delta value.</span>
sign_extended:

<span class="token comment">; At this point the value in the X register is either $00 or $FF, and the Accumulator still holds the delta value.</span>

<span class="token opcode property">CLC</span>       <span class="token comment">; Clear the Carry flag.</span>

<span class="token opcode property">ADC</span> <span class="token hexnumber string">$00</span>   <span class="token comment">; Add value at address $0000 to the delta value in the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$03</span>   <span class="token comment">; Store Accumulator in memory at address $0003.</span>
<span class="token opcode property">TXA</span>       <span class="token comment">; Transfer the high byte in the X register to the Accumulator.</span>

<span class="token opcode property">ADC</span> <span class="token hexnumber string">$01</span>   <span class="token comment">; Add value at address $0001 to the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$04</span>   <span class="token comment">; Store Accumulator in memory at address $0004.</span>
</code></pre>
<p>The sequence of bytes at the start of the zero page is now <code>30 00 9c cc ff</code>. Thus the correct value — <code>$FFCC</code> — has been stored (in little-endian format).</p>
<h3 id="subtraction" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#subtraction"><span>Subtraction</span></a></h3>
<p>Subtraction is performed using the SBC operation.</p>
<section class="opcode-detail">
<h5>SBC (Subtract memory from Accumulator with Borrow)</h5>
<p>Subtracts the byte value specified by the operand from the current value in the Accumulator, taking any borrow into account (with borrow being the complement of the Carry flag). The result of the subtraction is stored in the Accumulator.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Carry flag</td>
<td>Set if borrowing did not occur during the calculation, or cleared if borrowing did occur.</td>
</tr>
<tr>
<td>Overflow flag</td>
<td>Set if bit #7 of the result changed in a way that indicates overflow when subtracting signed byte values, otherwise cleared.</td>
</tr>
<tr>
<td>Zero flag</td>
<td>Set if the result is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the result.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Immediate</td>
<td><code class="language-asm6502"><span class="token opcode property">SBC</span> <span class="token hexnumber string">#$00</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">SBC</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">SBC</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">SBC</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Absolute, Y</td>
<td><code class="language-asm6502"><span class="token opcode property">SBC</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">Y</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">SBC</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>(Indirect, X)</td>
<td><code class="language-asm6502"><span class="token opcode property">SBC</span> (<span class="token hexnumber string">$00</span>, <span class="token register variable">X</span>)</code></td>
</tr>
<tr>
<td>(Indirect), Y</td>
<td><code class="language-asm6502"><span class="token opcode property">SBC</span> (<span class="token hexnumber string">$00</span>), <span class="token register variable">Y</span></code></td>
</tr>
</tbody>
</table>
</section>
<p>As I described earlier, the ALU implements subtraction as an addition. It first negates the byte to subtract by (the subtrahend). It also uses the state of the Carry flag to determine if it needs to add one as part of the negation process. (The ALU only adds one if the Carry flag is set.) This use of the Carry flag's current state works well when subtracting the non-LSB bytes of multi-byte signed values. But it fails when subtracting the LSBs unless we first set the Carry flag. We use the SEC operation to do so.</p>
<p>Notice how this is the opposite of addition: when adding we have to first clear the Carry flag, but when subtracting we have to first set that flag.</p>
<p>The following assembly demonstrates subtracting two 8-bit signed values:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token comment">; $FE - $01 (-2 - +1 in decimal)</span>

<span class="token opcode property">SEC</span>       <span class="token comment">; Set the Carry flag to indicate no borrow.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$01</span>  <span class="token comment">; Load $01 as an immediate value into the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>   <span class="token comment">; Store the Accumulator in memory at address $0000.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$FE</span>  <span class="token comment">; Load $FE as an immediate value into the Accumulator.</span>
<span class="token opcode property">SBC</span> <span class="token hexnumber string">$00</span>   <span class="token comment">; Subtract value at address $0000 from the Accumulator.</span>
</code></pre>
<p>After this code runs, the value in the Accumulator is now <code>$FD</code>, or -3 in decimal. The Overflow flag is not set, so the result is valid. The Carry flag is set, but we ignore that.</p>
<p>The following assembly demonstrates subtracting two 16-bit signed values:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token comment">; $FF80 - $0005 (-128 - +5 in decimal)</span>

<span class="token comment">; Load LSB of -128 in memory at address $0000.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$80</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>

<span class="token comment">; Load MSB of -128 in memory at address $0001.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$FF</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$01</span>

<span class="token comment">; Load LSB of +5 in memory at address $0002.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$05</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$02</span>

<span class="token comment">; Load MSB of +5 in memory at address $0003.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$00</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$03</span>

<span class="token opcode property">SEC</span>       <span class="token comment">; Set the Carry flag to indicate no borrow.</span>

<span class="token comment">; Add the LSBs.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$00</span>   <span class="token comment">; Load LSB of first value into the Accumulator.</span>
<span class="token opcode property">SBC</span> <span class="token hexnumber string">$02</span>   <span class="token comment">; Add LSB of second value to the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$04</span>   <span class="token comment">; Store LSB of result in memory at address $0004.</span>

<span class="token comment">; Carry flag is set here, indicating no borrow.</span>

<span class="token comment">; Add the MSBs, including the carry bit from the first addition.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$01</span>   <span class="token comment">; Load MSB of first value into the Accumulator.</span>
<span class="token opcode property">SBC</span> <span class="token hexnumber string">$03</span>   <span class="token comment">; Add MSB of second value to the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$05</span>   <span class="token comment">; Store LSB of result in memory at address $0005.</span>
</code></pre>
<p>After this code runs, the sequence of bytes at the start of the zero page is now <code>80 ff 05 00 7b ff</code>. Thus the correct value of <code>$FF7B</code>, or 133 in decimal, has been stored in little-endian format. The Overflow flag is not set, so the result is valid.</p>
<h3 id="bitwise-operations" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#bitwise-operations"><span>Bitwise operations</span></a></h3>
<p>Three <a href="https://en.wikipedia.org/wiki/Bitwise_operation">bitwise</a> operations are supported: AND, OR, and XOR.</p>
<section class="opcode-detail">
<h5>AND (AND memory with Accumulator)</h5>
<p>Performs a bitwise AND operation between the value in the Accumulator and the specified byte, storing the result in the Accumulator.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the result is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the result.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Immediate</td>
<td><code class="language-asm6502"><span class="token opcode property">AND</span> <span class="token hexnumber string">#$00</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">AND</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">AND</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">AND</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Absolute, Y</td>
<td><code class="language-asm6502"><span class="token opcode property">AND</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">Y</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">AND</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>(Indirect, X)</td>
<td><code class="language-asm6502"><span class="token opcode property">AND</span> (<span class="token hexnumber string">$00</span>, <span class="token register variable">X</span>)</code></td>
</tr>
<tr>
<td>(Indirect), Y</td>
<td><code class="language-asm6502"><span class="token opcode property">AND</span> (<span class="token hexnumber string">$00</span>), <span class="token register variable">Y</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>ORA (OR memory with Accumulator)</h5>
<p>Performs a bitwise OR operation between the value in the Accumulator and the specified byte, storing the result in the Accumulator.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the result is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the result.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Immediate</td>
<td><code class="language-asm6502"><span class="token opcode property">ORA</span> <span class="token hexnumber string">#$00</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">ORA</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">ORA</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">ORA</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Absolute, Y</td>
<td><code class="language-asm6502"><span class="token opcode property">ORA</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">Y</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">ORA</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>(Indirect, X)</td>
<td><code class="language-asm6502"><span class="token opcode property">ORA</span> (<span class="token hexnumber string">$00</span>, <span class="token register variable">X</span>)</code></td>
</tr>
<tr>
<td>(Indirect), Y</td>
<td><code class="language-asm6502"><span class="token opcode property">ORA</span> (<span class="token hexnumber string">$00</span>), <span class="token register variable">Y</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>EOR (Exclusive-OR memory with Accumulator)</h5>
<p>Performs a bitwise XOR operation between the value in the Accumulator and the specified byte, storing the result in the Accumulator.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the result is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the result.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Immediate</td>
<td><code class="language-asm6502"><span class="token opcode property">EOR</span> <span class="token hexnumber string">#$00</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">EOR</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">EOR</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">EOR</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Absolute, Y</td>
<td><code class="language-asm6502"><span class="token opcode property">EOR</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">Y</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">EOR</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>(Indirect, X)</td>
<td><code class="language-asm6502"><span class="token opcode property">EOR</span> (<span class="token hexnumber string">$00</span>, <span class="token register variable">X</span>)</code></td>
</tr>
<tr>
<td>(Indirect), Y</td>
<td><code class="language-asm6502"><span class="token opcode property">EOR</span> (<span class="token hexnumber string">$00</span>), <span class="token register variable">Y</span></code></td>
</tr>
</tbody>
</table>
</section>
<p>You can use the AND operation to clear bits in a given byte. This requires loading a suitable <a href="https://en.wikipedia.org/wiki/Mask_(computing)">bitmask</a> into the Accumulator. In the bitmask, the bits to clear are zeros and the other bits are ones. This example assembly shows how to clear bit #3 of a given byte:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token comment">; Set up the example.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$8F</span> <span class="token comment">; Load the value $8F (%10001111) into the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>  <span class="token comment">; Save the Accumulator to memory at address $0000.</span>

<span class="token comment">; Clear bit #3 of the byte at address $0000.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$00</span>  <span class="token comment">; Load the value at address $0000 into the Accumulator.</span>
<span class="token opcode property">AND</span> <span class="token hexnumber string">#$F7</span> <span class="token comment">; Perform the AND operation with the mask %11110111.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>  <span class="token comment">; Save the altered value back to memory at address $0000.</span>
</code></pre>
<p>After this code runs, the value in memory at address <code>$0000</code> is <code>%10000111</code>, or <code>$87</code> in hex.</p>
<p>You can use the ORA operation to clear bits in a given byte. This requires loading a suitable bitmask into the Accumulator. In the bitmask, the bits to set are ones and the other bits are zeros. This example assembly shows how to set bit #5 of a given byte:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token comment">; Set up the example.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$8F</span> <span class="token comment">; Load the value $8F (%10001111) into the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>  <span class="token comment">; Save the Accumulator to memory at address $0000.</span>

<span class="token comment">; Set bit #4 of the byte at address $0000.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$00</span>  <span class="token comment">; Load the value at address $0000 into the Accumulator.</span>
<span class="token opcode property">ORA</span> <span class="token hexnumber string">#$10</span> <span class="token comment">; Perform the OR operation with the mask %00010000.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>  <span class="token comment">; Save the altered value back to memory at address $0000.</span>
</code></pre>
<p>After this code runs, the value in memory at address <code>$0000</code> is <code>%10011111</code>, or <code>$9F</code> in hex.</p>
<p>You can use the EOR operation to flip bits in a given byte. This requires loading a suitable bitmask into the Accumulator. In the bitmask, the bits to flip are ones and the other bits are zeros. This example assembly shows how to flip all the bits of a given byte:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token comment">; Set up the example.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">#$8F</span> <span class="token comment">; Load the value $8F (%10001111) into the Accumulator.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>  <span class="token comment">; Save the Accumulator to memory at address $0000.</span>

<span class="token comment">; Flip all the bits of the byte at address $0000.</span>
<span class="token opcode property">LDA</span> <span class="token hexnumber string">$00</span>  <span class="token comment">; Load the value at address $0000 into the Accumulator.</span>
<span class="token opcode property">EOR</span> <span class="token hexnumber string">#$FF</span> <span class="token comment">; Perform the XOR operation with the mask %11111111.</span>
<span class="token opcode property">STA</span> <span class="token hexnumber string">$00</span>  <span class="token comment">; Save the altered value back to memory at address $0000.</span>
</code></pre>
<p>After this code runs, the value in memory at address <code>$0000</code> is <code>%01110000</code>, or <code>$70</code> in hex.</p>
<h3 id="operations-for-incrementing-and-decrementing-the-index-registers" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#operations-for-incrementing-and-decrementing-the-index-registers"><span>Operations for incrementing and decrementing the index registers</span></a></h3>
<p>The primary role for the X and Y registers is in indexing. To support this role, there are increment and decrement operations for both registers.</p>
<section class="opcode-detail">
<h5>INX (Increment X register by One)</h5>
<p>Increments the value in the X register by one, wrapping around so that the result of incrementing <code>$FF</code> is <code>$00</code>. The Carry flag is not affected.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the result is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the result.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">INX</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>INY (Increment Y register by One)</h5>
<p>Increments the value in the Y register by one, wrapping around so that the result of incrementing <code>$FF</code> is <code>$00</code>. The Carry flag is not affected.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the result is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the result.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">INY</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>DEX (Decrement X register by One)</h5>
<p>Decrements the value in the X register by one, wrapping around so that the result of decrementing <code>$00</code> is <code>$FF</code>. The Carry flag is not affected.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the result is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the result.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">DEX</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>DEY (Decrement Y register by One)</h5>
<p>Decrements the value in the Y register by one, wrapping around so that the result of decrementing <code>$00</code> is <code>$FF</code>. The Carry flag is not affected.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the result is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the result.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">DEY</span></code></td>
</tr>
</tbody>
</table>
</section>
<h3 id="operations-for-incrementing-and-decrementing-memory" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#operations-for-incrementing-and-decrementing-memory"><span>Operations for incrementing and decrementing memory</span></a></h3>
<p>If you want to mutate a byte in memory, you have to first load it into a register, operate on it, and then copy it back to memory. There are two exceptions to this: the INC and DEC operations. These allow you to increment and decrement bytes in memory without needing to use a register. This is useful for implementing counters in memory, and for setting or clearing bit #0 of a byte in memory. (If you initialise bit #0 of such a byte to a zero, incrementing the byte by one will set that bit. If you then decrement the byte by one you will clear that bit. This is regardless of the values of the other bits in the byte.)</p>
<p>It takes more CPU cycles to increment or decrement a value in memory than in a register. But it is more efficient overall since you do not need to shuffle memory to and from a register.</p>
<section class="opcode-detail">
<h5>INC (Increment Memory by One)</h5>
<p>Increments the value in the specified byte in memory by one, wrapping around so that the result of incrementing <code>$FF</code> is <code>$00</code>. The Carry flag is not affected.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the result is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the result.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">INC</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">INC</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">INC</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">INC</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>DEC (Decrement Memory by One)</h5>
<p>Decrements the value in the specified byte in memory by one, wrapping around so that the result of decrementing <code>$00</code> is <code>$FF</code>. The Carry flag is not affected.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the result is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the result.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">DEC</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">DEC</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">DEC</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">DEC</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
</tbody>
</table>
</section>
<h3 id="operations-for-byte-comparison" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#operations-for-byte-comparison"><span>Operations for byte comparison</span></a></h3>
<p>Comparison is a common operation in programming. The 6502 has operations for comparing the byte specified by the operand with either the Accumulator, the X register, or the Y register. The result of the comparison is not stored anywhere. Thus you can perform a comparison without disturbing the contents of those registers.</p>
<p>The comparison instructions are often used with the branch instructions. I cover these later in this post.</p>
<section class="opcode-detail">
<h5>CMP (Compare Memory with Accumulator)</h5>
<p>Subtracts the byte specified by the operand from the value in the Accumulator, then uses the result to update the state of the Negative, Zero and Carry flags. The result of the subtraction is not stored anywhere.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Carry flag</td>
<td>Set if the value in the Accumulator is greater than or equal to the operand byte, otherwise cleared.</td>
</tr>
<tr>
<td>Zero flag</td>
<td>Set if the value in the Accumulator is equal to the operand byte, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the result.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Immediate</td>
<td><code class="language-asm6502"><span class="token opcode property">CMP</span> <span class="token hexnumber string">#$00</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">CMP</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">CMP</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">CMP</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Absolute, Y</td>
<td><code class="language-asm6502"><span class="token opcode property">CMP</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">Y</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">CMP</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>(Indirect, X)</td>
<td><code class="language-asm6502"><span class="token opcode property">CMP</span> (<span class="token hexnumber string">$00</span>, <span class="token register variable">X</span>)</code></td>
</tr>
<tr>
<td>(Indirect), Y</td>
<td><code class="language-asm6502"><span class="token opcode property">CMP</span> (<span class="token hexnumber string">$00</span>), <span class="token register variable">Y</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>CPX (Compare Memory and Index Register X)</h5>
<p>Subtracts the byte specified by the operand from the value in the X register, then uses the result to update the state of the Negative, Zero and Carry flags. The result of the subtraction is not stored anywhere.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Carry flag</td>
<td>Set if the value in the X register is greater than or equal to the operand byte, otherwise cleared.</td>
</tr>
<tr>
<td>Zero flag</td>
<td>Set if the value in the X register is equal to the operand byte, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the result.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Immediate</td>
<td><code class="language-asm6502"><span class="token opcode property">CPX</span> <span class="token hexnumber string">#$00</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">CPX</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">CPX</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>CPY (Compare Memory and Index Register Y)</h5>
<p>Subtracts the byte specified by the operand from the value in the Y register, then uses the result to update the state of the Negative, Zero and Carry flags. The result of the subtraction is not stored anywhere.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Carry flag</td>
<td>Set if the value in the Y register is greater than or equal to the operand byte, otherwise cleared.</td>
</tr>
<tr>
<td>Zero flag</td>
<td>Set if the value in the Y register is equal to the operand byte, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the result.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Immediate</td>
<td><code class="language-asm6502"><span class="token opcode property">CPY</span> <span class="token hexnumber string">#$00</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">CPY</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">CPY</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
</tbody>
</table>
</section>
<p>With these comparisons, it is the state of the Carry and Zero flags that are useful for making program flow decisions:</p>
<ul>
<li>The Carry flag is not set when the register value is less than the operand byte.</li>
<li>The Carry flag is set when the register value is greater than or equal to the operand byte.</li>
<li>The Zero flag is set when the two bytes compare as equal.</li>
</ul>
<h4 id="the-bit-operation" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#the-bit-operation"><span>The BIT operation</span></a></h4>
<p>The byte comparison operations (CMP, CPX and CPY) are useful for comparing whole bytes. But sometimes you only want to test particular bits of a byte in the CPU's address space. You can do this using the BIT operation.</p>
<p>A BIT operation performs a bitwise AND operation between the Accumulator and the specified byte in memory. The value in the Accumulator is normally a bitmask for the test. The result of the operation is either zero or non-zero. If it is zero then none of the bits tested were set in both bytes. If it is non-zero then one or more of the bits tested were set in both bytes. The CPU uses the Zero flag of the Processor Status register to communicate this result. The CPU also updates the Negative and Overflow flags, but only to the state of bits #7 and #6 of the byte in memory. They are not affected by the value in the Accumulator.</p>
<p>The result of the AND operation is not stored anywhere; the value in the Accumulator is not updated. This is in contrast to the AND <em>bitwise</em> operation. With that operation, the result is stored in the Accumulator.</p>
<section class="opcode-detail">
<h5>BIT (Test Bits in Memory with Accumulator)</h5>
<p>Performs a bitwise AND operation between the value in the Accumulator and the specified byte in the CPU's address space. The value in the Accumulator is not updated.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the result of the AND operation is zero (none of the bits tested were set in both bytes), otherwise cleared.</td>
</tr>
<tr>
<td>Overflow flag</td>
<td>Updated to equal bit #6 of the specified memory byte.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to equal bit #7 of the specified memory byte.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">BIT</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">BIT</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
</tbody>
</table>
</section>
<p>The following assembly code tests if bit #1 is set in the byte at address <code>$0C01</code>:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">LDA</span> <span class="token binarynumber string">#%00000010</span> <span class="token comment">; Load a bitmask into the Accumulator to isolate bit #1.</span>
<span class="token opcode property">BIT</span> <span class="token hexnumber string">$0C01</span>      <span class="token comment">; Test the byte at address $0C01 against the bitmask.</span>
</code></pre>
<p>Let us say that the byte value at that address is <code>%10001111</code>. After the BIT instruction the state of the Processor Status register will be as follows:</p>
<ul>
<li>The Negative flag will be set.</li>
<li>The Overflow flag will not be set.</li>
<li>The Zero flag will not be set.</li>
</ul>
<p>Since the Zero flag is not set, we know that bit #1 of the byte at address <code>$0C01</code> is set; this is the correct result.</p>
<p>As I mentioned, the CPU updates the Negative and Overflow flags based only on the state of the byte in memory specified by the operand. If you only need to check if bit #7 or bit #6 of a byte in memory is set, you do not need to first load a bitmask into the Accumulator. This makes it more efficient to check the state of these particular bits (rather than bits #0 to #5) because you can omit an LDA instruction. You also do not overwrite the value that is already in the Accumulator. Thus bit #7 and bit #6 are the best bits to use for any flags in your programs.</p>
<h3 id="bit-shift-operations" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#bit-shift-operations"><span>Bit shift operations</span></a></h3>
<p>A <a href="https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts">bit shift</a> is a type of bitwise operation where the bits of a value are shifted to the left or to the right. The 6502 supports two types of bit shift — shift and rotate — with a left and a right version of each.</p>
<p>For both types, the bits of the specified byte are shift by one bit to the left or right. The bit that is shifted out of the byte is stored in the Carry flag. (The Carry flag is used as a ninth bit for the operation.) The different between the two types of bit shift is the handling of the bit that is shifted in. For the shift type, the shifted-in bit is always a zero. For the rotate type, the shifted-in bit is set to the old value of the Carry flag.</p>
<p>The following diagram visualises the effect of LSR, the shift right operation:</p>
<p></p><figure class="article-image">  <div style="max-width: 576px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 16.23263888888889%;">      <img src="./6502_files/lsr-2x.png" alt="The effect of LSR, the shift right operation" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>The effect of LSR, the shift right operation</figcaption></figure><p></p>
<p>The following diagram visualises the effect of ROR, the rotate right operation. It shows how the shifted-in bit is treated differently compared to LSR:</p>
<p></p><figure class="article-image">  <div style="max-width: 549px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 24.499089253187613%;">      <img src="./6502_files/ror-2x.png" alt="The effect of ROR, the rotate right operation" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>The effect of ROR, the rotate right operation</figcaption></figure><p></p>
<p>The following diagram visualises the effect of ASL, the shift left operation:</p>
<p></p><figure class="article-image">  <div style="max-width: 579.5px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 16.22088006902502%;">      <img src="./6502_files/asl-2x.png" alt="The effect of ASL, the shift left operation" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>The effect of ASL, the shift left operation</figcaption></figure><p></p>
<p>The following diagram visualises the effect of ROL, the rotate left operation. It shows how the shifted-in bit is treated differently compared to ASL:</p>
<p></p><figure class="article-image">  <div style="max-width: 549px; margin-left: auto; margin-right: auto;">    <div style="width: 100%; height: 0; padding-bottom: 23.770491803278688%;">      <img src="./6502_files/rol-2x.png" alt="The effect of ROL, the rotate left operation" loading="lazy" style="width: 100%;">    </div>  </div>  <figcaption>The effect of ROL, the rotate left operation</figcaption></figure><p></p>
<section class="opcode-detail">
<h5>LSR (Shift One Bit Right (Memory or Accumulator))</h5>
<p>Shifts the bits of the specified byte one bit to the right, i.e., bit #7 becomes bit #6, bit #6 becomes bit #5, and so on. The new value of bit #7 is zero. The old value of bit #0 is stored in the Carry flag.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the shifted byte is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Always cleared (because bit #7 becomes zero).</td>
</tr>
<tr>
<td>Carry flag</td>
<td>The old value of bit #0 is stored here.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accumulator</td>
<td><code class="language-asm6502"><span class="token opcode property">LSR</span> <span class="token register variable">A</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">LSR</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">LSR</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">LSR</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">LSR</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>ASL (Shift Left One Bit (Memory or Accumulator))</h5>
<p>Shifts the bits of the specified byte one bit to the left, i.e., bit #0 becomes bit #1, bit #1 becomes bit #2, etc. The new value of bit #0 is zero. The old value of bit #7 is stored in the Carry flag.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the shifted byte is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Set to the value of bit #7 in the shifted byte.</td>
</tr>
<tr>
<td>Carry flag</td>
<td>The old value of bit #7 is stored here.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accumulator</td>
<td><code class="language-asm6502"><span class="token opcode property">ASL</span> <span class="token register variable">A</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">ASL</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">ASL</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">ASL</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">ASL</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>ROL (Rotate One Bit Left (Memory or Accumulator))</h5>
<p>Rotates the bits of the specified byte by one bit to the left, i.e., bit #0 becomes bit #1, bit #1 becomes bit #2, etc. The new value of bit #0 comes from the Carry flag, and then the old value of bit #7 is used to update the Carry flag.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the rotated byte is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Set to the value of the new bit #7 (which was bit #6 in the original byte).</td>
</tr>
<tr>
<td>Carry flag</td>
<td>The old value of bit #7 is stored here.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accumulator</td>
<td><code class="language-asm6502"><span class="token opcode property">ROL</span> <span class="token register variable">A</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">ROL</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">ROL</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">ROL</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">ROL</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>ROR (Rotate One Bit Right (Memory or Accumulator))</h5>
<p>Rotates the bits of the specified byte by one bit to the right, i.e., bit #7 becomes bit #6, bit #6 becomes bit #5, and so on. The new value of bit #7 comes from the Carry flag, and then the old value of bit #0 is used to update the Carry flag.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the rotated byte is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Set to the previous value of the Carry flag.</td>
</tr>
<tr>
<td>Carry flag</td>
<td>The old value of bit #0 is stored here.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accumulator</td>
<td><code class="language-asm6502"><span class="token opcode property">ROR</span> <span class="token register variable">A</span></code></td>
</tr>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">ROR</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Zero Page</td>
<td><code class="language-asm6502"><span class="token opcode property">ROR</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
<tr>
<td>Absolute, X</td>
<td><code class="language-asm6502"><span class="token opcode property">ROR</span> <span class="token hexnumber string">$0000</span>, <span class="token register variable">X</span></code></td>
</tr>
<tr>
<td>Zero Page, X</td>
<td><code class="language-asm6502"><span class="token opcode property">ROR</span> <span class="token hexnumber string">$00</span>, <span class="token register variable">X</span></code></td>
</tr>
</tbody>
</table>
</section>
<h3 id="the-jmp-operation" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#the-jmp-operation"><span>The JMP operation</span></a></h3>
<p>The Program Counter stores the address of the next instruction for the CPU. Normally the CPU is automatically updating the address in this register. It increments the address so that it sequentially executes the program. But in any non-trivial program you will need more control. For example, you might want to conditionally execute a particular instruction. Or you might want to loop over a sequence of instructions a certain number of times. For this, there are operations for adjusting the value of the Program Counter.</p>
<p>A simple means of controlling program execution is the JMP operation. This is like the 'goto' instruction that exists in some programming languages. It is an unconditional update of the Program Counter to the address specified as the operand.</p>
<section class="opcode-detail">
<h5>JMP (Jump to New Location)</h5>
<p>Sets the Program Counter to the memory location specified by the operand.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">JMP</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
<tr>
<td>Absolute Indirect</td>
<td><code class="language-asm6502"><span class="token opcode property">JMP</span> (<span class="token hexnumber string">$0000</span>)</code></td>
</tr>
</tbody>
</table>
</section>
<p>Note that normally you would use a label as the operand, rather than a literal address.</p>
<p>You can use a JMP instruction to create an infinite loop:</p>
<pre class="language-asm6502"><code class="language-asm6502">loop:
  <span class="token comment">; Put any instructions here</span>
  <span class="token comment">; that you want to repeat forever.</span>
  <span class="token opcode property">JMP</span> loop
</code></pre>
<h3 id="branch-operations" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#branch-operations"><span>Branch operations</span></a></h3>
<p>A JMP instruction results in an unconditional update of the Program Counter. But sometimes you only want to update the Program Counter if some condition is true. You can do this using one of eight branch operations. Each tests the condition of a particular flag in the Processor Status register. The instruction only updates the Program Counter if that flag has a particular state. If the flag is not in the required state, the instruction has no effect. Program execution continues sequentially as normal.</p>
<p>There are eight branch operations. Each branch operation does not update the state of any Processor Status flags. Each only supports the Relative addressing mode.</p>
<section class="opcode-detail">
<h5>BMI (Branch on Result Minus)</h5>
<p>Only branches if the Negative flag is set.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Relative</td>
<td><code class="language-asm6502"><span class="token opcode property">BMI</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>BPL (Branch on Result Plus)</h5>
<p>Only branches if the Negative flag is not set.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Relative</td>
<td><code class="language-asm6502"><span class="token opcode property">BPL</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>BVS (Branch on Overflow Set)</h5>
<p>Only branches if the Overflow flag is set.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Relative</td>
<td><code class="language-asm6502"><span class="token opcode property">BVS</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>BVC (Branch on Overflow Clear)</h5>
<p>Only branches if the Overflow flag is not set.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Relative</td>
<td><code class="language-asm6502"><span class="token opcode property">BVC</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>BCS (Branch on Carry Set)</h5>
<p>Only branches if the Carry flag is set.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Relative</td>
<td><code class="language-asm6502"><span class="token opcode property">BCS</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>BCC (Branch on Carry Clear)</h5>
<p>Only branches if the Carry flag is not set.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Relative</td>
<td><code class="language-asm6502"><span class="token opcode property">BCC</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>BEQ (Branch on Result Zero)</h5>
<p>Only branches if the Zero flag is set.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Relative</td>
<td><code class="language-asm6502"><span class="token opcode property">BEQ</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>BNE (Branch on Result Not Zero)</h5>
<p>Only branches if the Zero flag is not set.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Relative</td>
<td><code class="language-asm6502"><span class="token opcode property">BNE</span> <span class="token hexnumber string">$00</span></code></td>
</tr>
</tbody>
</table>
</section>
<p>The operand for each branch instruction is a single byte. It is a relative shift that the CPU should apply to the Program Counter if the branch condition evaluates to true. The fact that the operand is a single byte means that the resulting shift can only be in the range -128 to +127 inclusive. You cannot branch to anywhere in your program in the way that you can with a JMP instruction.</p>
<p>This restriction is a deliberate optimisation by the 6502's designers. A program will typically include many branch instructions. Using a one-byte shift rather than a two-byte address means that they are one byte smaller. Over an entire program, this results in a useful reduction in program size. If you do make the mistake of trying to branch too far, the assembler should emit an error.</p>
<p>Normally you would use a label as the operand for a branch instruction:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">BMI</span> some_label <span class="token comment">; some_label is declared elsewhere.</span>
</code></pre>
<p>When using a label, the assembler automatically replaces it by a calculated value. This is the relative shift required to jump from the branch to the label declaration.</p>
<p>Branch instructions are often used with the byte comparison and bit test instructions. (These are CMP, CPX, CPY, and BIT.) First you perform a test using one of the comparison instructions. Then you use a branch instruction to branch based on the result of that test. You can use this technique to create <a href="https://en.wikipedia.org/wiki/For_loop">for-loops</a>.</p>
<p>Say you want to initialise a sequence of 8 bytes in memory. The address range of the sequence is <code>$0010</code> to <code>$0017</code> and you want to set all the bytes to the value <code>$FF</code>. The following assembly implements this using a for-loop in the form <code>for (i = 0; i &lt; 8; i++)</code>:</p>
<pre class="language-asm6502"><code class="language-asm6502">  <span class="token opcode property">LDA</span> <span class="token hexnumber string">#$FF</span> <span class="token comment">; Load the Accumulator with the value to set all bytes to.</span>
  <span class="token opcode property">LDX</span> <span class="token hexnumber string">#$00</span> <span class="token comment">; Load the X register with the initial value for the loop counter.</span>
loop:
  <span class="token comment">; The loop body</span>
  <span class="token opcode property">STA</span> <span class="token hexnumber string">$10</span>, <span class="token register variable">X</span> <span class="token comment">; Set the value of the byte at $0010 + X to $FF.</span>
  <span class="token comment">;</span>
  <span class="token opcode property">INX</span>      <span class="token comment">; Increment the loop counter in the X register</span>
  <span class="token opcode property">CPX</span> <span class="token hexnumber string">#$08</span> <span class="token comment">; Compare the limit value ($08) with the value in the X register.</span>
           <span class="token comment">; If the X register contains the value $08 then the Zero flag gets set.</span>
  <span class="token opcode property">BNE</span> loop <span class="token comment">; Loop if the Zero flag is not set.</span>
  <span class="token comment">; Execution continues here if the branch is not taken.</span>
</code></pre>
<p>The branch condition initially evaluates as true and so the CPU takes the branch. Eventually the value in the X register is equal to the limit value. In the above code that limit value is <code>$08</code>. The branch is now not taken and the loop exits.</p>
<p>A more efficient approach is to count down rather than up:</p>
<pre class="language-asm6502"><code class="language-asm6502">  <span class="token opcode property">LDA</span> <span class="token hexnumber string">#$FF</span> <span class="token comment">; Load the Accumulator with the value to set all bytes to.</span>
  <span class="token opcode property">LDX</span> <span class="token hexnumber string">#$07</span> <span class="token comment">; Load the X register with the limit value minus one.</span>
loop:
  <span class="token comment">; The loop body</span>
  <span class="token opcode property">STA</span> <span class="token hexnumber string">$10</span>, <span class="token register variable">X</span> <span class="token comment">; Set the value of the byte at $0010 + X to $FF.</span>
  <span class="token comment">;</span>
  <span class="token opcode property">DEX</span>      <span class="token comment">; Decrement the value of X register,</span>
           <span class="token comment">; which sets the Negative flag if X is now less than zero.</span>
  <span class="token opcode property">BPL</span> loop <span class="token comment">; Loop if the Negative flag is not set.</span>
  <span class="token comment">; Execution continues here if the branch is not taken.</span>
</code></pre>
<p>By counting down, you do not need a comparison instruction. This is because the DEX instruction does not only decrement the value in the X register. It also sets the Negative flag if the value in the X register is now less than zero. Now you can use the BPL instruction to branch based on that Negative flag. This is without having to first perform a comparison.</p>
<p>Counting down in this way forces you to treat the counter as a signed byte. This means that the maximum possible starting value for the counter is +127 rather than 255. An alternative is to initialise the X register to the limit value and use BEQ for the branch instruction. This permits a maximum starting value of 255. But the downside that the counter is no longer <a href="https://en.wikipedia.org/wiki/Zero-based_numbering#Usage_in_programming_languages">zero-based</a>.</p>
<p>If you do need to index more than 256 bytes, you can use one of the two techniques described on pages 94 and 95 of the <a href="http://archive.6502.org/books/mcs6500_family_programming_manual.pdf">MOS MCS6500 programming manual</a>.</p>
<p>If you need to branch to a location that is too far away, you can combine a JMP instruction with a contrary (a.k.a. complementary) branch instruction. You use the JMP instruction to reach the desired location. You use the branch instruction to conditionally skip over that JMP instruction:</p>
<pre class="language-asm6502"><code class="language-asm6502">  <span class="token opcode property">LDA</span> <span class="token hexnumber string">#$00</span>               <span class="token comment">; Load the Accumulator with the value to test</span>
  <span class="token opcode property">BEQ</span> no_jump            <span class="token comment">; Skip the jump if the Accumulator value is zero</span>
  <span class="token opcode property">JMP</span> some_distant_label <span class="token comment">; Jump if that value is not zero.</span>
no_jump:
  <span class="token comment">; Code here that executes if there was no jump.</span>
</code></pre>
<p>A common selection mechanism in a high level language is the <a href="https://en.wikipedia.org/wiki/Switch_statement">switch statement</a>. You can create it by combining the byte comparison and branch instructions. The following is a pseudo-code switch statement. It tests the value in the Accumulator against a series of constants to decide how to proceed:</p>
<pre class="language-clike"><code class="language-clike">switch <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  case <span class="token number">0</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  case <span class="token number">1</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  case <span class="token number">2</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  default<span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre>
<p>You can create it in assembly like so:</p>
<pre class="language-asm6502"><code class="language-asm6502">  <span class="token opcode property">LDA</span> <span class="token hexnumber string">#$01</span>      <span class="token comment">; Load the value to test into the Accumulator.</span>
  <span class="token opcode property">CMP</span> <span class="token hexnumber string">#$00</span>      <span class="token comment">; Compare case 0 to the Accumulator.</span>
  <span class="token opcode property">BEQ</span> a_is_zero <span class="token comment">; Branch to the a_is_zero label if the Accumulator contains 0.</span>
  <span class="token opcode property">CMP</span> <span class="token hexnumber string">#$01</span>      <span class="token comment">; Compare case 1 to the Accumulator.</span>
  <span class="token opcode property">BEQ</span> a_is_one  <span class="token comment">; Branch to the a_is_one label if the Accumulator contains 1.</span>
  <span class="token opcode property">CMP</span> <span class="token hexnumber string">#$02</span>      <span class="token comment">; Compare case 2 to the Accumulator.</span>
  <span class="token opcode property">BEQ</span> a_is_two  <span class="token comment">; Branch to the a_is_two label if the Accumulator contains 2.</span>
  <span class="token comment">; Default behaviour here.</span>
</code></pre>
<h3 id="operations-for-subroutines-and-call-stack-management" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#operations-for-subroutines-and-call-stack-management"><span>Operations for subroutines and call stack management</span></a></h3>
<p>The JMP and branch instructions are very useful for controlling program execution. But there is a common programming construct that they do not support: the <a href="https://en.wikipedia.org/wiki/Subroutine">subroutine</a>. A subroutine is a sequence of instructions for performing some task. It is useful when we want to invoke that sequence at various points during program execution. It is usually identified with a label. We could use a JMP instruction to start executing it, but what should happen at the subroutine's end? We cannot JMP back because we could have invoked the subroutine from many possible locations in the program code. We would not know which particular location to return to. And what should happen when that subroutine itself invokes a subroutine?</p>
<p>We need to be able to remember the value of the Program Counter when we enter a subroutine. Doing so would allow use to restore that value to the Program Counter on exit. We also need to be able to do this in a nested fashion, to support calling subroutines from subroutines.</p>
<p>The solution to this problem is a data structure called the <a href="https://en.wikipedia.org/wiki/Call_stack">call stack</a>. Being a stack it supports pushing values onto it and then popping them off. The CPU implements the call stack as a top-down stack. This means that it grows downwards in memory rather than upwards. One page of system RAM, from addresses <code>$0100</code> to <code>$01FF</code>, is assigned to it. (This is the page right after the zero page.)</p>
<p>The Stack Pointer keeps track of the top of the stack. This register is only one byte in size. This is okay because only a single page is used for the stack; the MSB of any stack address will always be <code>$01</code>. When a byte is pushed onto the stack, the Stack Pointer is decremented by one. When a byte is popped from the stack, the Stack Pointer is incremented by one.</p>
<p>We <em>must</em> initialise the value of the Stack Pointer at program start. We do this using the TXS operation from earlier in this post. Because the stack is a top-down stack, we have to initialise the Stack Pointer to the value <code>$FF</code>. This is the LSB of the address of the stack page's last byte.</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token comment">; Initialising the call stack:</span>
<span class="token opcode property">LDX</span> <span class="token hexnumber string">#$FF</span>
<span class="token opcode property">TXS</span>
</code></pre>
<p>To invoke a subroutine, we use the the JSR operation. The operand is the address of the subroutine. You would normally specify this using the subroutine's label. When a JSR instruction is executed, the CPU performs the following actions:</p>
<ul>
<li>It pushes the current value of the Program Counter onto the Stack. This is an address so it is two bytes of data.</li>
<li>It decrements the Stack Pointer by two bytes.</li>
<li>It updates the Program Counter to the address of the specified subroutine.</li>
</ul>
<p>Use the RTS operation to exit a subroutine. When it reaches the RTS instruction, the CPU will perform the following actions:</p>
<ul>
<li>It fetches the current value of the Stack Pointer.</li>
<li>It reads the values of the two bytes above that location in the stack.</li>
<li>It interprets these two bytes as an address in memory and it uses them to update the Program Counter's value.</li>
<li>It increments the Stack Point by two bytes, so 'removing' that stored address from the stack.</li>
</ul>
<section class="opcode-detail">
<h5>JSR (Jump to Subroutine Saving Return Address)</h5>
<p>Jumps to a new location in the program code. Also pushes the current value of the Program Counter onto the stack (two bytes).</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Absolute</td>
<td><code class="language-asm6502"><span class="token opcode property">JSR</span> <span class="token hexnumber string">$0000</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>RTS (Return from Subroutine)</h5>
<p>Pops the top two bytes off of the stack and uses them to update the value of the Program Counter.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">RTS</span></code></td>
</tr>
</tbody>
</table>
</section>
<p>Since only one page of memory is allocated to the stack, there is a limit to how deeply you can nest subroutine calls. (The result of exceeding this limit is termed <a href="https://en.wikipedia.org/wiki/Stack_overflow">stack overflow</a>.) It is unlikely that you will ever reach this limit. It is more likely that you will not need to devote the entire stack page to the stack. In that case you are free to treat the unused space as regular system RAM. Since the stack grows downwards from <code>$01FF</code>, it is the initial bytes of the stack page that would be unused.</p>
<p>The MOS MCS6500 programming manual includes the following guidance about subroutines:</p>
<figure class="c-blockquote">
<blockquote cite="./6502_files/proman.html">
<p>[T]he use of subroutines should be limited to those cases where the user expects to duplicate code of significant length several times in the program. In these cases, and only in these cases, is subroutine call warranted rather than the normal mode of knowing the addresses and specifying them in an instruction. In all cases where timing [is] of significant interest, subroutines should also be avoided. Subroutines add significantly to the setup and execution time of problem solution.</p>
</blockquote>
<figcaption class="c-blockquote__attribution">— <a href="./6502_files/proman.html">Section 8.8, MOS MCS6500 microcomputer family programming manual</a></figcaption>
</figure>
<p>When entering a subroutine, you might need to store more than the value of the Program Counter. You might have a particular value in the Accumulator before you call the subroutine. The subroutine might load a different value into the Accumulator. When the subroutine returns, you would not be able to pick up from where you were before.</p>
<p>To deal with this, you can push the value of the Accumulator and the Processor Status register on to the stack. You can also pop them off. This allows you to save extra information onto the stack. You have to manage pushing and popping this data yourself. Perform pushing right at the start of the subroutine, and popping before returning.</p>
<section class="opcode-detail">
<h5>PHA (Push Accumulator on Stack)</h5>
<p>Pushes the current value of the Accumulator onto the stack.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">PHA</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>PHP (Push Processor Status register on Stack)</h5>
<p>Pushes the current value of the Processor Status register onto the stack.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">PHP</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>PLA (Pull Accumulator from Stack)</h5>
<p>Pops the topmost byte from the stack and stores it in the Accumulator.</p>
<h6>Processor Status register changes</h6>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zero flag</td>
<td>Set if the copied value is zero, otherwise cleared.</td>
</tr>
<tr>
<td>Negative flag</td>
<td>Updated to the value of bit #7 of the copied value.</td>
</tr>
</tbody>
</table>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">PLA</span></code></td>
</tr>
</tbody>
</table>
</section>
<section class="opcode-detail">
<h5>PLP (Pull Processor Status register from Stack)</h5>
<p>Pops the topmost byte from the stack and stores it in the Processor Status register.</p>
<h6>Processor Status register changes</h6>
<p>Updates all flags since the entire value for this register is popped from the stack.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">PLP</span></code></td>
</tr>
</tbody>
</table>
</section>
<p>The following assembly demonstrates storing and restoring the value of the Accumulator:</p>
<pre class="language-asm6502"><code class="language-asm6502">  <span class="token opcode property">LDA</span> <span class="token hexnumber string">#$44</span> <span class="token comment">; Store some value in the Accumulator.</span>
  <span class="token opcode property">JSR</span> some_subroutine <span class="token comment">; Invoke the subroutine.</span>

some_subroutine:
  <span class="token opcode property">PHA</span> <span class="token comment">; Push the existing value in the Accumulator to the stack.</span>

  <span class="token comment">; Perform the subroutine instructions.</span>
  <span class="token comment">; Here I just change the value in the Accumulator.</span>
  <span class="token opcode property">LDA</span> <span class="token hexnumber string">#$11</span> <span class="token comment">; Store a different value in the Accumulator.</span>

  <span class="token opcode property">PLA</span> <span class="token comment">; Restore the old value of the Accumulator.</span>
  <span class="token opcode property">RTS</span> <span class="token comment">; Return from the subroutine.</span>
</code></pre>
<h3 id="operations-for-interrupt-handling" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#operations-for-interrupt-handling"><span>Operations for interrupt handling</span></a></h3>
<p>Sometimes a system event will occur that requires your program's immediate attention. For example, the player might have pressed the Reset button on the NES, or the PPU might have started vblank. We term such an event an <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>.</p>
<p>The 6502 supports three types of interrupt event:</p>
<ul>
<li>The Reset event.</li>
<li>The interrupt request / break (IRQ/BRK) event.</li>
<li>The non-maskable interrupt (NMI) event.</li>
</ul>
<p>You have to include a handler in your program code for each of these three event types. Each handler is a subroutine invoked by the CPU when the corresponding event type occurs. You use an <a href="https://en.wikipedia.org/wiki/Interrupt_vector_table">interrupt vector table</a> to map each of the three event types to its handler. Each entry in the table is the address of the handler. The very last six bytes of the CPU's address space, <code>$FFFA</code> to <code>$FFFF</code>, is reserved for this table. Every program that you write must include it and it must be found at that particular range of addresses. Note that the table is not executable code — it is only a sequence of three two-byte addresses.</p>
<p>The three addresses, or vectors, in the table are organised as follows:</p>
<table>
<thead>
<tr>
<th>Addresses</th>
<th>Vector</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$FFFA</code> and <code>$FFFB</code></td>
<td>NMI</td>
</tr>
<tr>
<td><code>$FFFC</code> and <code>$FFFD</code></td>
<td>Reset</td>
</tr>
<tr>
<td><code>$FFFE</code> and <code>$FFFF</code></td>
<td>IRQ/BRK</td>
</tr>
</tbody>
</table>
<p>As is standard for the 6502, these addresses are stored in little-endian format. The following is an example of creating the interrupt vector table in assembly:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token directive keyword">.segment</span> <span class="token string">"INTERRUPT_VECTORS"</span>
<span class="token directive keyword">.addr</span> nmi_handler
<span class="token directive keyword">.addr</span> reset_handler
<span class="token directive keyword">.addr</span> irq_brk_handler
</code></pre>
<p>The assembler control command syntax to used to embed the addresses of the handlers. The <code>.segment</code> control command positions the vector table at the correct address. I will explain how this works in a future post.</p>
<h4 id="the-reset-event" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#the-reset-event"><span>The Reset event</span></a></h4>
<p>The Reset event is special. It only occurs when the player powers the NES on or when they press the Reset button while the NES is running. When it is signalled, the CPU performs the following initialisation sequence:</p>
<ol>
<li>The Interrupt Disable flag is set.</li>
<li>The Program Counter is set to the value of the Reset vector.</li>
</ol>
<p>Your program now begins execution.</p>
<p>The value of the Reset vector is the address of the first instruction for the CPU to execute on program start. This will be the start of your program's initialisation code. Then your program will likely enter an infinite loop that is your main game loop. Thus the Reset handler never returns.</p>
<h4 id="the-nmi-and-irq%2Fbrk-events" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#the-nmi-and-irq%2Fbrk-events"><span>The NMI and IRQ/BRK events</span></a></h4>
<p>The NMI and IRQ/BRK events occur many times during program execution. The handlers for these two events need to deal with exiting the handler as well as entering it. These events will also interrupt the regular execution of your program. You may need to save particular program state on entering a handler and then restore it on exit.</p>
<p>This is the effective sequence of actions that occur when an interrupt is signalled:</p>
<ol>
<li>The CPU pushes the current value of the Program Counter onto the stack.</li>
<li>The CPU pushes the current value of the Processor Status register onto the stack.</li>
<li>The CPU reads the vector for the particular type of interrupt that has occurred (NMI or IRQ/BRK).</li>
<li>The CPU sets the value of the Program Counter to that vector.</li>
<li>The CPU sets the Interrupt Disable flag of the Processor Status register. This prevents any other IRQ/BRK interrupts from occurring.</li>
</ol>
<p>Now program execution continues within the handler. When you wish to exit the handler, you must do so using an RTI instruction.</p>
<section class="opcode-detail">
<h5>RTI (Return from Interrupt)</h5>
<p>Pops the topmost byte from the stack and uses it to update the Processor Status register, then pops the next two bytes from the stack and uses them to update the Program Counter.</p>
<h6>Processor Status register changes</h6>
<p>Updates all flags since the entire value for this register is updated.</p>
<p>Effectively clears the Interrupt Disable flag if the updated value does not have this flag set.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">RTI</span></code></td>
</tr>
</tbody>
</table>
</section>
<p>This is effective sequence of event that occurs when a handler is exited via an RTI instruction:</p>
<ol>
<li>The CPU pops the old value of the Processor Status register from the stack.</li>
<li>The CPU updates the value of the Processor Status register to that old value. If the old value did not have the Interrupt Disable flag set then this re-enables maskable interrupts.</li>
<li>The CPU pops the old value of the Program Counter from the stack.</li>
<li>The CPU updates the value of the Program Counter to that old value.</li>
</ol>
<p>The CPU only pushes the values of the Processor Status register and Program Counter onto the stack. Your interrupt handler code will likely alter the values of other registers. If you wish to save them then you need to push them to the stack immediately on entering the handler and pop them before exiting.</p>
<p>The difference between the NMI and IRQ/BRK interrupt is that the latter is maskable while the former is not. A maskable interrupt is one that you can silence, meaning that the CPU will ignore whenever it occurs. This will happen as long as the Interrupt Disable flag of the Processor Status register is set. As I covered earlier in this post, you can use the SEI and CLI operations to set and clear the Interrupt Disable flag.</p>
<p>But some interrupts are very important and they have to be handled as quickly as possible. For these cases, the 6502 includes the NMI (non-maskable interrupt). It is not affected by the Interrupt Disable flag. The NES has a single NMI: for the interrupt event that occurs when the PPU starts vblank. This event occurs 60 times a second and indicates when the PPU is idle and so when you can update its state.</p>
<p>The 6502 includes a BRK operation that you can use to signal the IRQ/BRK interrupt event. This causes the IRQ/BRK event handler to be executed.</p>
<section class="opcode-detail">
<h5>BRK (Force Break)</h5>
<p>Saves the current values of the Processor Status register and Program Counter to the call stack. Transfers control to the IRQ/BRK vector. The break occurs even if the Interrupt Disable flag in the Processor Status register is set (i.e., interrupts are masked).</p>
<h6>Processor Status register changes</h6>
<p>Sets the Interrupt Disable flag.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">BRK</span></code></td>
</tr>
</tbody>
</table>
</section>
<p>The BRK instruction is useful for debugging. You can insert the instruction in your program where you would like to examine the state of the system. It causes the IRQ / BRK event handler to be invoked, at which point you can perform some debug actions. But this handler gets invoked both when a maskable interrupt event occurs and when you use a BRK instruction. You need to be able to detect the latter case in your handler. When an interrupt occurs the CPU pushes the Processor Status register value to the stack. If the interrupt is because of a BRK instruction, that value is first updated so that the Break flag is set. This allows you, in your IRQ / BRK event handler, to check if the interrupt is actually a break interrupt:</p>
<pre class="language-asm6502"><code class="language-asm6502"><span class="token opcode property">PLA</span>      <span class="token comment">; Pop the top byte from stack into the Accumulator.</span>
<span class="token opcode property">PHA</span>      <span class="token comment">; Push it back onto the stack.</span>
<span class="token opcode property">AND</span> <span class="token hexnumber string">#$10</span> <span class="token comment">; Bit-test the Break Flag</span>
<span class="token opcode property">BNE</span> your_break_routine <span class="token comment">; Branch to your break interrupt handling.</span>
<span class="token comment">; Normal interrupt handling here.</span>
</code></pre>
<h3 id="the-no-op-operation" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#the-no-op-operation"><span>The no-op operation</span></a></h3>
<p>The final operation to cover is NOP, the no-op operation. An instruction that does nothing seems to be pointless, but it does have its uses:</p>
<figure class="c-blockquote">
<blockquote cite="./6502_files/NOP_">
<p>A NOP is most commonly used for timing purposes, to force memory alignment, to prevent hazards, to occupy a branch delay slot, to render void an existing instruction such as a jump, or as a place-holder to be replaced by active instructions later on in program development (or to replace removed instructions when reorganising would be problematic or time-consuming).</p>
</blockquote>
<figcaption class="c-blockquote__attribution">— <a href="https://en.wikipedia.org/wiki/NOP_(code)">Wikipedia</a></figcaption>
</figure>
<section class="opcode-detail">
<h5>NOP (No Operation)</h5>
<p>Does nothing. It is one byte in size and takes two clock cycles to execute.</p>
<h6>Processor Status register changes</h6>
<p>Does not update any flags.</p>
<h6>Supported addressing modes</h6>
<table>
<thead>
<tr>
<th>Addressing mode</th>
<th>Example instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td><code class="language-asm6502"><span class="token opcode property">NOP</span></code></td>
</tr>
</tbody>
</table>
</section>
<h3 id="the-unofficial-opcodes" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#the-unofficial-opcodes"><span>The unofficial opcodes</span></a></h3>
<p>As stated in this post, there are 151 official opcodes. Since an opcode is one byte in length and one byte can define 256 values, there are other possible opcode values. What would happen if a machine instruction were to have an opcode value that is not one of the 151 official values?</p>
<p>The result would depend on the exact unofficial value used. For some values, the result is a no-op or the NES will freeze until you press the Reset button. For others there are useful effects and <a href="https://wiki.nesdev.com/w/index.php/CPU_unofficial_opcodes#Games_using_unofficial_opcodes">a few NES games</a> have made use of them. You can read a good description <a href="https://www.pagetable.com/?p=39">here</a> of why the unofficial opcodes have the effects they do. <a href="https://wiki.nesdev.com/w/index.php/Programming_with_unofficial_opcodes">This page</a> on the Nesdev wiki looks at which unofficial opcodes are actually useable.</p>
<h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#conclusion"><span>Conclusion</span></a></h2>
<p>If you have not done any low-level programming before then writing games for the NES involves learning many new concepts. The information presented here should provide a solid base for your NES adventure.</p>
<h2 id="further-reading" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#further-reading"><span>Further reading</span></a></h2>
<ul>
<li><a href="http://archive.6502.org/books/mcs6500_family_programming_manual.pdf">MOS MCS6500 microcomputer family programming manual</a>.</li>
</ul>
<hr>
<h2 id="changelog" tabindex="-1"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#changelog"><span>Changelog</span></a></h2>
<ul>
<li>2020-06-23 Draft version</li>
<li>2020-08-02 A substantial rework of the explanations for addition and subtraction.</li>
<li>2020-08-26 Plain English improvements</li>
<li>2021-10-21 Fixed a link</li>
</ul>

                <article>
                    <h2 id="comments"><a class="header-anchor" href="https://www.middle-engine.com/blog/posts/2020/06/23/programming-the-nes-the-6502-in-detail#comments">#</a> Comments</h2>
                    <p class="note">
                        Comments on this site are implemented using GitHub Issues.
                        To add your comment, please add it
                        to <a href="https://github.com/stevejay/middleengine-website/issues/47">this GitHub
                            Issue</a>. It will then appear below.</p>
                    <comments-list owner="stevejay" repo="middleengine-website" issue-number="47" issue-endpoint="https://middleengine-website-comments.vercel.app/octomments/issue"><template shadowrootmode="open"><div><ul><li><p><address class="author">Posted by <a rel="author" href="https://github.com/pspaulding">pspaulding</a></address> on <time pubdate="" datetime="2021-07-09T12:22:38Z" title="09/07/2021, 22:22:38">09/07/2021</time> —</p><p dir="auto">Great article!</p></li><li><p><address class="author">Posted by <a rel="author" href="https://github.com/chiro79">chiro79</a></address> on <time pubdate="" datetime="2022-01-08T00:45:08Z" title="08/01/2022, 11:45:08">08/01/2022</time> —</p><p dir="auto">Very useful and well written article. Congrats!</p></li><li><p><address class="author">Posted by <a rel="author" href="https://github.com/HawksLincoln">HawksLincoln</a></address> on <time pubdate="" datetime="2022-03-12T03:10:29Z" title="12/03/2022, 14:10:29">12/03/2022</time> —</p><p dir="auto">Fantastic read and well detailed, even for the novice look forward to more solid reading!</p></li></ul></div><style>
        ul {
          margin: 0;
          padding-left: 0;
          list-style: none;
        }
        address {
         display: inline;
        }
        a {
          color: var(--octomments-link-color);
        }
        li p:first-of-type {
          font-size: 0.875em;
          font-style: italic;
          color: var(--octomments-meta-color);
        }
        li + li {
          border-top: 1px dashed var(--octomments-divider-color);
        }</style><script src="https://unpkg.com/octomments@1.0.4/build/ocs-core.min.js" id="ocs-core.min.js"></script></template>
                    </comments-list>
                </article>
            </div>
        </article>
    </main>
    <footer id="site-footer" data-turbolinks-permanent="">
      <div class="content-wrap">
        <p>© 2021 Middle Engine Software Ltd<br>
          <a href="https://www.freepik.com/free-photos-vectors/business">Business
            vector created by studiogstock - www.freepik.com</a></p>
        <ul>
          <li><a href="https://www.middle-engine.com/">Home</a></li>
          <li><a href="https://www.middle-engine.com/blog">Blog</a></li>
          <li><a href="https://www.middle-engine.com/legal">Terms &amp; conditions</a></li>
          <li><a href="https://www.middle-engine.com/privacy">Privacy policy</a></li>
        </ul>
      </div>
    </footer>


</body></html>